"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[9795],{38634:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"iowarp/components/runtime/modules","title":"Building Modules","description":"Chimaera\'s objective is to be flexible towards a variety of I/O stack designs. The main step","source":"@site/docs/11-iowarp/03-components/03-runtime/04-modules.md","sourceDirName":"11-iowarp/03-components/03-runtime","slug":"/iowarp/components/runtime/modules","permalink":"/docs/iowarp/components/runtime/modules","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Launch Runtime","permalink":"/docs/iowarp/components/runtime/launch-runtime"},"next":{"title":"Deploying Modules","permalink":"/docs/iowarp/components/runtime/deploying-mods"}}');var t=s(74848),o=s(28453);const r={},i="Building Modules",l={},c=[{value:"Module Repos",id:"module-repos",level:2},{value:"Bootstrap a New Module in a Repo",id:"bootstrap-a-new-module-in-a-repo",level:2},{value:"Refresh the module repo",id:"refresh-the-module-repo",level:3},{value:"Try Compiling",id:"try-compiling",level:3},{value:"Declare all tasks",id:"declare-all-tasks",level:2},{value:"Autogenerate task helper files",id:"autogenerate-task-helper-files",level:2},{value:"Autogenerated tasks structs",id:"autogenerated-tasks-structs",level:3},{value:"CHI_BEGIN, CHI_END, CHI_AUTOGEN_METHODS",id:"chi_begin-chi_end-chi_autogen_methods",level:4},{value:"Autogenerated client APIs",id:"autogenerated-client-apis",level:3},{value:"What is CHI_TASK_METHODS?",id:"what-is-chi_task_methods",level:4},{value:"Autogenerated runtime APIs",id:"autogenerated-runtime-apis",level:3},{value:"Try building",id:"try-building",level:3},{value:"Customize your new tasks",id:"customize-your-new-tasks",level:2},{value:"Define the CreateTask",id:"define-the-createtask",level:3},{value:"Define the CompressTask",id:"define-the-compresstask",level:3},{value:"Task inheritance",id:"task-inheritance",level:4},{value:"Task variables",id:"task-variables",level:4},{value:"Emplace constructor: Method Signature",id:"emplace-constructor-method-signature",level:4},{value:"Emplace Constructor: Core Task Parameters",id:"emplace-constructor-core-task-parameters",level:4},{value:"Emplace Constructor: Custom Parameters",id:"emplace-constructor-custom-parameters",level:4},{value:"CopyStart",id:"copystart",level:4},{value:"SerializeStart",id:"serializestart",level:4},{value:"SerializeEnd",id:"serializeend",level:4},{value:"Define the DecompressTask",id:"define-the-decompresstask",level:3},{value:"SerializeStart",id:"serializestart-1",level:4},{value:"SerializeEnd",id:"serializeend-1",level:4},{value:"Define your Client API",id:"define-your-client-api",level:2},{value:"Modify Create",id:"modify-create",level:3},{value:"Modify Compress + Decompress",id:"modify-compress--decompress",level:3},{value:"Define your Runtime implementation",id:"define-your-runtime-implementation",level:2},{value:"Modify Create",id:"modify-create-1",level:3},{value:"Review MapTaskToLane",id:"review-maptasktolane",level:3},{value:"Modify Decompress and Compress",id:"modify-decompress-and-compress",level:3},{value:"What are the Monitor* methods?",id:"what-are-the-monitor-methods",level:3},{value:"Compile + Install",id:"compile--install",level:2},{value:"Invoking your mods",id:"invoking-your-mods",level:2},{value:"Link to your mods (Internally)",id:"link-to-your-mods-internally",level:2},{value:"Link to your mods (Externally)",id:"link-to-your-mods-externally",level:2},{value:"Locate your module",id:"locate-your-module",level:3},{value:"Target link libraries",id:"target-link-libraries",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"building-modules",children:"Building Modules"})}),"\n",(0,t.jsx)(n.p,{children:"Chimaera's objective is to be flexible towards a variety of I/O stack designs. The main step\nto achieve this is through modularity. It is possible to create and dynamically register\nnew custom modules in the chimaera runtime. This section discusses how this modularity is\nachieved and what can be done with it."}),"\n",(0,t.jsx)(n.p,{children:"We will explain this process by adding an example compression module to a custom repo.\nChimaera does follow a strict naming convention to allow for more\ncode to be generated. We document here the expectations on certain key variable and class\nnames to ensure that code is properly generated."}),"\n",(0,t.jsx)(n.h2,{id:"module-repos",children:"Module Repos"}),"\n",(0,t.jsxs)(n.p,{children:["In Chimaera, a module (or ",(0,t.jsx)(n.strong,{children:"ChiMod"}),") is the code object representing a ChiContainer. These\nmodules can be registered dynamically in the runtime. A module repo represents a set of\nChiMods. In the example below, we show the set of core modules defined\nby Chimaera. These include modules for block devices (bdev), networking (remote_queue),\nwork orchestration policies (worch_proc_round_robin and worch_queue_round_robin), and lastly\nthe Chimaera Admin, which is responsible for general runtime tasks (e.g., upgrading modules,\ncreating new ChiPools, etc.)."]}),"\n",(0,t.jsx)(n.p,{children:'In the tree output below, the folder named "tasks" is the module repo.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chimaera\n\u251c\u2500\u2500 benchmark\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 src\n\u251c\u2500\u2500 tasks\n    \u251c\u2500\u2500 bdev\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 chimaera_admin\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 remote_queue\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 small_message\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 TASK_NAME\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 worch_proc_round_robin\n    \u2502   \u251c\u2500\u2500 CMakeLists.txt\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 src\n    \u2514\u2500\u2500 worch_queue_round_robin\n        \u251c\u2500\u2500 CMakeLists.txt\n        \u251c\u2500\u2500 include\n        \u2514\u2500\u2500 src\n"})}),"\n",(0,t.jsx)(n.p,{children:"Module repos can be attached as a subdirectory to a project -- or it can\nbe the entire project itself. In the above example, we demonstrate a case\nwhere the repo is apart of a broader project."}),"\n",(0,t.jsx)(n.p,{children:"A module repo can be created as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_make_repo /path/to/repo namespace\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_make_repo ~/my_mod_repo example\n"})}),"\n",(0,t.jsx)(n.p,{children:'The namespace is used to help autogenerate cmakes. When you build your project,\nother projects will be able to link to it using "namespace::my_mod_name".'}),"\n",(0,t.jsx)(n.p,{children:"At this time, the repo should look as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"my_mod_repo\n\u251c\u2500\u2500 chimaera_repo.yaml\n\u2514\u2500\u2500 CMakeLists.txt\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"chimaera_repo.yaml"}),": Recommended against touching directly. Indicates\nthis is a module repo and provides some metadata (mainly the namespace)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CMakeLists.txt"}),": The cmake that will be used to build the modules\nin the repo, when we make them."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"bootstrap-a-new-module-in-a-repo",children:"Bootstrap a New Module in a Repo"}),"\n",(0,t.jsxs)(n.p,{children:["To create a module, use the ",(0,t.jsx)(n.code,{children:"chi_make_mod"})," command. This is installed\nas part of the library chimaera-util, which is a dependency of iowarp.\nBelow is an example where we create the compressor module within the\nmy_mod_repo repo."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_make_mod ~/my_mod_repo/compressor\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, ",(0,t.jsx)(n.code,{children:"chi_make_mod"})," copy-pastes the TASK_NAME module from chimaera\nand renames it (and associated classes / namespaces) to be compressor. The\npath does not need to be absolute."]}),"\n",(0,t.jsx)(n.p,{children:"This will create a module with the following directory structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"my_mod_repo\n\u251c\u2500\u2500 chimaera_repo.yaml  # Repo metadata\n\u251c\u2500\u2500 CMakeLists.txt      # Repo cmake\n\u2514\u2500\u2500 compressor\n    \u251c\u2500\u2500 chimaera_mod.yaml  # Module metadata\n    \u251c\u2500\u2500 CMakeLists.txt     # Module cmake\n    \u251c\u2500\u2500 include\n    \u2502\xa0\xa0 \u2514\u2500\u2500 compressor\n    \u2502\xa0\xa0     \u251c\u2500\u2500 compressor_client.h      # Client API\n    \u2502\xa0\xa0     \u251c\u2500\u2500 compressor_lib_exec.h    # (autogenerated from *methods.yaml)\n    \u2502\xa0\xa0     \u251c\u2500\u2500 compressor_methods.h     # (autogenerated from *methods.yaml)\n    \u2502\xa0\xa0     \u251c\u2500\u2500 compressor_methods.yaml  # Task declarations \n    \u2502\xa0\xa0     \u2514\u2500\u2500 compressor_tasks.h       # Task struct definitions \n    \u2514\u2500\u2500 src\n        \u251c\u2500\u2500 CMakeLists.txt          # Builds compressor_client and runtime  \n        \u251c\u2500\u2500 compressor_client.cc    # Client API source\n        \u251c\u2500\u2500 compressor_monitor.py   # Used for monitoring\n        \u2514\u2500\u2500 compressor_runtime.cc   # Runtime API source\n"})}),"\n",(0,t.jsx)(n.h3,{id:"refresh-the-module-repo",children:"Refresh the module repo"}),"\n",(0,t.jsx)(n.p,{children:"To ensure that the repo's cmakes all know of the new module, run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_refresh_repo ~/my_mod_repo\n"})}),"\n",(0,t.jsx)(n.h3,{id:"try-compiling",children:"Try Compiling"}),"\n",(0,t.jsx)(n.p,{children:"You should be able to compile this code as-is."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd ~/my_mod_repo\nmkdir build\ncd build\ncmake ..\nmake -j32\n"})}),"\n",(0,t.jsx)(n.h2,{id:"declare-all-tasks",children:"Declare all tasks"}),"\n",(0,t.jsxs)(n.p,{children:["The first file to consider is the ",(0,t.jsx)(n.code,{children:"include/compressor/compressor_methods.yaml"}),". This file declares\nthe set of tasks that your module exposes by giving each task a unique\nidentifier. By unique, we mean that each task declared within this file should\nbe distinct. In other words, the ID does not need to be unique across modules."]}),"\n",(0,t.jsxs)(n.p,{children:["Your ",(0,t.jsx)(n.code,{children:"*_methods.yaml"})," file will initially look as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# Inherited Methods\nkCreate: 0        # 0\nkDestroy: 1       # 1\nkNodeFailure: -1  # 2\nkRecover: -1      # 3\nkMigrate: -1      # 4\nkUpgrade: -1       # 5\n\n# Custom Methods (start from 10)\n# kCustom: 10\n\n# NOTE: When you add a new method, \n# call chi_refresh_repo to update\n# all autogenerated files.\n"})}),"\n",(0,t.jsx)(n.p,{children:"Inherited methods are common across all modules. Of these,\nonly kCreate is strictly required. The others are optional,\nwhich is indicated by setting -1 to avoid code generation for them."}),"\n",(0,t.jsx)(n.p,{children:"Custom methods can range from 10 to 2^32. Let's add the methods\nkCompress and kDecompress."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# Inherited Methods\nkCreate: 0        # 0\nkDestroy: 1       # 1\nkNodeFailure: -1  # 2\nkRecover: -1      # 3\nkMigrate: -1      # 4\nkUpgrade: -1       # 5\n\n# Custom Methods (start from 10)\nkCompress: 10\nkDecompress: 11\n"})}),"\n",(0,t.jsx)(n.h2,{id:"autogenerate-task-helper-files",children:"Autogenerate task helper files"}),"\n",(0,t.jsx)(n.p,{children:"To autogenerate the Compress and Decompress functions, we can run the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_refresh_repo ~/my_mod_repo\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will edit various files to bootstrap code for you."}),"\n",(0,t.jsx)(n.h3,{id:"autogenerated-tasks-structs",children:"Autogenerated tasks structs"}),"\n",(0,t.jsxs)(n.p,{children:["A task is simply a C++ struct containing the parameters to a function.\nTasks are located in ",(0,t.jsx)(n.code,{children:"include/compressor/compressor_tasks.h"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'CHI_BEGIN(Create)\n/** A task to create compressor */\nstruct CreateTaskParams {\n  CLS_CONST char *lib_name_ = "example_compressor";\n\n  HSHM_INLINE_CROSS_FUN\n  CreateTaskParams() = default;\n\n  HSHM_INLINE_CROSS_FUN\n  CreateTaskParams(const hipc::CtxAllocator<CHI_ALLOC_T> &alloc) {}\n\n  template <typename Ar>\n  HSHM_INLINE_CROSS_FUN void serialize(Ar &ar) {}\n};\ntypedef chi::Admin::CreatePoolBaseTask<CreateTaskParams> CreateTask;\nCHI_END(Create)\n\nCHI_BEGIN(Destroy)\n/** A task to destroy compressor */\ntypedef chi::Admin::DestroyContainerTask DestroyTask;\nCHI_END(Destroy)\n\nCHI_BEGIN(Compress)\n/** The CompressTask task */\nstruct CompressTask : public Task, TaskFlags<TF_SRL_SYM> {\n  /** SHM default constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc)\n      : Task(alloc) {}\n\n  /** Emplace constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kCompress;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n  }\n\n  /** Duplicate message */\n  void CopyStart(const CompressTask &other, bool deep) {}\n\n  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {}\n\n  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {}\n};\nCHI_END(Compress)\n\nCHI_BEGIN(Decompress)\n/** The DecompresssTask task */\nstruct DecompresssTask : public Task, TaskFlags<TF_SRL_SYM> {\n  /** SHM default constructor */\n  HSHM_INLINE explicit DecompresssTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc)\n      : Task(alloc) {}\n\n  /** Emplace constructor */\n  HSHM_INLINE explicit DecompresssTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kDecompresss;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n  }\n\n  /** Duplicate message */\n  void CopyStart(const DecompresssTask &other, bool deep) {}\n\n  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {}\n\n  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {}\n};\nCHI_END(Decompress)\n\nCHI_AUTOGEN_METHODS  // keep at class bottom\n'})}),"\n",(0,t.jsx)(n.h4,{id:"chi_begin-chi_end-chi_autogen_methods",children:"CHI_BEGIN, CHI_END, CHI_AUTOGEN_METHODS"}),"\n",(0,t.jsx)(n.p,{children:"Notice that each task is wrapped in CHI_BEGIN and CHI_END.\nFor example, Decompress:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"CHI_BEGIN(Decompress)\n/** The DecompresssTask task */\nstruct DecompresssTask : public Task, TaskFlags<TF_SRL_SYM> {\n  /** SHM default constructor */\n  HSHM_INLINE explicit DecompresssTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc)\n      : Task(alloc) {}\n\n  /** Emplace constructor */\n  HSHM_INLINE explicit DecompresssTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kDecompresss;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n  }\n\n  /** Duplicate message */\n  void CopyStart(const DecompresssTask &other, bool deep) {}\n\n  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {}\n\n  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {}\n};\nCHI_END(Decompress)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CHI_BEGIN"})," and ",(0,t.jsx)(n.code,{children:"CHI_END"})," encapsulate a piece of code\nrelating to a task. ",(0,t.jsx)(n.code,{children:"CHI_AUTOGEN_METHODS"})," marks the end\nof the class where methods not wrapped in these could be\nappended. ",(0,t.jsx)(n.code,{children:"CHI_AUTOGEN_METHODS"})," is mainly\na fallback and the other decorators are prioritized."]}),"\n",(0,t.jsxs)(n.p,{children:["These exist to allow the Chimaera utility library to parse\nthese files and make edits to them. For example, a task\ncould be deleted by removing everything between ",(0,t.jsx)(n.code,{children:"CHI_BEGIN"})," and\n",(0,t.jsx)(n.code,{children:"CHI_END"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"autogenerated-client-apis",children:"Autogenerated client APIs"}),"\n",(0,t.jsxs)(n.p,{children:["The next file to look at is your client API: ",(0,t.jsx)(n.code,{children:"include/compressor/compressor_client.h"}),".\nFor any application that will interact with your module, this is the API that\nthey will use."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"/** Create compressor requests */\nclass Client : public ModuleClient {\n public:\n  /** Default constructor */\n  HSHM_INLINE_CROSS_FUN\n  Client() = default;\n\n  /** Destructor */\n  HSHM_INLINE_CROSS_FUN\n  ~Client() = default;\n\n  CHI_BEGIN(Create)\n  /** Create a pool */\n  HSHM_INLINE_CROSS_FUN\n  void Create(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n              const DomainQuery &affinity, const chi::string &pool_name,\n              const CreateContext &ctx = CreateContext()) {\n    FullPtr<CreateTask> task =\n        AsyncCreate(mctx, dom_query, affinity, pool_name, ctx);\n    task->Wait();\n    Init(task->ctx_.id_);\n    CHI_CLIENT->DelTask(mctx, task);\n  }\n  CHI_TASK_METHODS(Create);\n  CHI_END(Create)\n\n  CHI_BEGIN(Destroy)\n  /** Destroy pool + queue */\n  HSHM_INLINE_CROSS_FUN\n  void Destroy(const hipc::MemContext &mctx, const DomainQuery &dom_query) {\n    CHI_ADMIN->DestroyContainer(mctx, dom_query, id_);\n  }\n  CHI_END(Destroy)\n\n  CHI_BEGIN(Compress)\n  /** Compress task */\n  void Compress(const hipc::MemContext &mctx, const DomainQuery &dom_query) {\n    FullPtr<CompressTask> task = AsyncCompress(mctx, dom_query);\n    task->Wait();\n    CHI_CLIENT->DelTask(mctx, task);\n  }\n  CHI_TASK_METHODS(Compress);\n  CHI_END(Compress)\n\n  CHI_BEGIN(Decompress)\n  /** Decompresss task */\n  void Decompresss(const hipc::MemContext &mctx, const DomainQuery &dom_query) {\n    FullPtr<DecompresssTask> task = AsyncDecompresss(mctx, dom_query);\n    task->Wait();\n    CHI_CLIENT->DelTask(mctx, task);\n  }\n  CHI_TASK_METHODS(Decompresss);\n  CHI_END(Decompress)\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"The class name should always be Client. However, you can change the namespace however you\nlike, so long as it is done consistently across all files in the module repo. This\ncan be easily done in any text editor."}),"\n",(0,t.jsx)(n.h4,{id:"what-is-chi_task_methods",children:"What is CHI_TASK_METHODS?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CHI_TASK_METHODS"})," is a macro that creates several useful APIs. This primarily\nincludes methods that abstract lower-level Chimaera APIs for allocating and\nsubmitting tasks."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CHI_TASK_METHODS(Create)"})," makes the following methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"template <typename... Args>   \nHSHM_CROSS_FUN hipc::FullPtr<CreateTask> AsyncCreateAlloc(        \n    const hipc::MemContext &mctx, const TaskNode &task_node,            \n    const DomainQuery &dom_query, Args &&...args) {                     \n  hipc::FullPtr<CUSTOM##Task> task = CHI_CLIENT->NewTask<CUSTOM##Task>( \n      mctx, task_node, id_, dom_query, std::forward<Args>(args)...);    \n  return task;                                                          \n}                                              \n\ntemplate <typename... Args>                                             \nHSHM_CROSS_FUN hipc::FullPtr<CreateTask> AsyncCreate(               \n    const hipc::MemContext &mctx, Args &&...args) {                     \n  return CHI_CLIENT->ScheduleNewTask<CreateTask>(                     \n      mctx, id_, std::forward<Args>(args)...);                          \n}      \n\ntemplate <typename... Args>                                             \nHSHM_CROSS_FUN hipc::FullPtr<CreateTask> AsyncCreateBase(         \n    const hipc::MemContext &mctx, chi::Task *parent,                    \n    const chi::TaskNode &task_node, Args &&...args) {                   \n  return CHI_CLIENT->ScheduleNewTask<CreateTask>(                     \n      mctx, parent, task_node, id_, std::forward<Args>(args)...);       \n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AsyncCreateAlloc"}),": Allocates a CreateTask (but does not schedule it).\nTypically used more for debugging."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AsyncCreate"}),": Allocates + schedules a CreateTask. Users will often\ncall this API."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AsyncCreateBase"}),': Allocates + Schedules a task, but explicitly states\nwhether or not the task was spawned as a subtask of another "parent" task.\nThis API is generally used only internally.']}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"autogenerated-runtime-apis",children:"Autogenerated runtime APIs"}),"\n",(0,t.jsxs)(n.p,{children:["The last file to consider is ",(0,t.jsx)(n.code,{children:"src/compressor_runtime.cc"}),". This file\ncontains the code that will be executed by the runtime. It holds\na class named Server. This class should always be named Server."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'class Server : public Module {\n public:\n  CLS_CONST LaneGroupId kDefaultGroup = 0;\n\n public:\n  Server() = default;\n\n  CHI_BEGIN(Create)\n  /** Construct compressor */\n  void Create(CreateTask *task, RunContext &rctx) {\n    // Create a set of lanes for holding tasks\n    CreateLaneGroup(kDefaultGroup, 1, QUEUE_LOW_LATENCY);\n  }\n  void MonitorCreate(MonitorModeId mode, CreateTask *task, RunContext &rctx) {}\n  CHI_END(Create)\n\n  /** Route a task to a lane */\n  Lane *MapTaskToLane(const Task *task) override {\n    // Route tasks to lanes based on their properties\n    // E.g., a strongly consistent filesystem could map tasks to a lane\n    // by the hash of an absolute filename path.\n    return GetLaneByHash(kDefaultGroup, task->prio_, 0);\n  }\n\n  CHI_BEGIN(Destroy)\n  /** Destroy compressor */\n  void Destroy(DestroyTask *task, RunContext &rctx) {}\n  void MonitorDestroy(MonitorModeId mode, DestroyTask *task, RunContext &rctx) {\n  }\n  CHI_END(Destroy)\n\n  CHI_BEGIN(Compress)\n  /** The Compress method */\n  void Compress(CompressTask *task, RunContext &rctx) {}\n  void MonitorCompress(MonitorModeId mode, CompressTask *task,\n                       RunContext &rctx) {\n    switch (mode) {\n      case MonitorMode::kReplicaAgg: {\n        std::vector<FullPtr<Task>> &replicas = *rctx.replicas_;\n      }\n    }\n  }\n  CHI_END(Compress)\n\n  CHI_BEGIN(Decompress)\n  /** The Decompresss method */\n  void Decompresss(DecompresssTask *task, RunContext &rctx) {}\n  void MonitorDecompresss(MonitorModeId mode, DecompresssTask *task,\n                          RunContext &rctx) {\n    switch (mode) {\n      case MonitorMode::kReplicaAgg: {\n        std::vector<FullPtr<Task>> &replicas = *rctx.replicas_;\n      }\n    }\n  }\n  CHI_END(Decompress)\n\n public:\n#include "compressor/compressor_lib_exec.h"\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"compressor/compressor_lib_exec.h"})," contains methods for routing tasks to the\nmethods shown here. For example, a task with the method ",(0,t.jsx)(n.code,{children:"Method::kCompress"})," will\nbe mapped to the function ",(0,t.jsx)(n.code,{children:"Compress"})," because of this file."]}),"\n",(0,t.jsx)(n.h3,{id:"try-building",children:"Try building"}),"\n",(0,t.jsx)(n.p,{children:"At this point, the code should compile again:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd ~/my_mod_repo\ncd build\ncmake ..\nmake -j32\n"})}),"\n",(0,t.jsx)(n.h2,{id:"customize-your-new-tasks",children:"Customize your new tasks"}),"\n",(0,t.jsxs)(n.p,{children:["A task is simply a C++ struct containing the parameters to a function.\nTasks are located in ",(0,t.jsx)(n.code,{children:"include/compressor/compressor_tasks.h"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"We will be editing this file now."}),"\n",(0,t.jsx)(n.h3,{id:"define-the-createtask",children:"Define the CreateTask"}),"\n",(0,t.jsxs)(n.p,{children:["The create task contains the parameters to initialize a ChiPool.\nAll CreateTasks must provide a constant ",(0,t.jsx)(n.code,{children:"lib_name_"}),". This is constant is\nthe base name of the ChiMod shared object (e.g., *.so or *.dll). This value is automatically\ngenerated and shouldn't be changed. It corresponds to the\n",(0,t.jsx)(n.code,{children:"target_link_library"})," command in the cmake file that is also autogenerated."]}),"\n",(0,t.jsx)(n.p,{children:"In our case, we will modify CreateTaskParams to include the identifier of a\ncompression library. We modify the non-default constructor and the serialization function.\nThe serialization function in particular is important."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'struct CreateTaskParams {\n  CLS_CONST char *lib_name_ = "example_compressor";\n  int compress_id_;\n\n  HSHM_INLINE_CROSS_FUN\n  CreateTaskParams() = default;\n\n  HSHM_INLINE_CROSS_FUN\n  CreateTaskParams(const hipc::CtxAllocator<CHI_ALLOC_T> &alloc,\n                   int compress_id = 0) {\n    compress_id_ = compress_id;\n  }\n\n  template <typename Ar>\n  HSHM_INLINE_CROSS_FUN void serialize(Ar &ar) {\n    ar(compress_id_);\n  }\n};\ntypedef chi::Admin::CreatePoolBaseTask<CreateTaskParams> CreateTask;\n'})}),"\n",(0,t.jsx)(n.h3,{id:"define-the-compresstask",children:"Define the CompressTask"}),"\n",(0,t.jsx)(n.p,{children:"The CompressTask has two main inputs: a buffer pointing to data to compress\nand the size of the data."}),"\n",(0,t.jsxs)(n.p,{children:["Below, we show our modified ",(0,t.jsx)(n.code,{children:"CompressTask"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct CompressTask : public Task, TaskFlags<TF_SRL_SYM> {\n  IN hipc::Pointer data_;\n  IN size_t data_size_;\n\n  /** SHM default constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc)\n      : Task(alloc) {}\n\n  /** Emplace constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query,\n      const hipc::Pointer &data, size_t data_size)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kCompress;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n    data_ = data;\n    data_size_ = data_size;\n  }\n\n  /** Duplicate message */\n  void CopyStart(const CompressTask &other, bool deep) {\n    data_ = other.data_;\n    data_size_ = other.data_size_;\n    if (!deep) {\n      UnsetDataOwner();\n    }\n  }\n\n  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {\n    ar.bulk(DT_WRITE, data_, data_size_);\n  }\n\n  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {}\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"NOTE: Tasks are not directly compatible with virtual functions.\nTasks are generally stored and allocated in shared memory. Since function\naddresses are not consistent across processes, using virtual functions,\nraw pointers, and STL data structures is generally erronous."}),"\n",(0,t.jsx)(n.h4,{id:"task-inheritance",children:"Task inheritance"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct CompressTask : public Task, TaskFlags<TF_SRL_SYM>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["CompressTask inherit from two base classes ",(0,t.jsx)(n.code,{children:"Task"})," and ",(0,t.jsx)(n.code,{children:"TaskFlags"}),".\nThe ",(0,t.jsx)(n.code,{children:"Task"})," class contains various variables and helper functions which\nwill be discussed more later."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"TaskFlags"}),' is used to enable/disable certain methods of a task.\nIn this case, TF_SRL_SYM means "this task can be serialized\nand transferred over a network." The alternative is TF_LOCAL,\nwhich means "This task executes on this node only."']}),"\n",(0,t.jsx)(n.p,{children:"When using TF_SRL_SYM, all of these methods are required to be implemented.\nWhen using TF_LOCAL, only CopyStart is required."}),"\n",(0,t.jsx)(n.h4,{id:"task-variables",children:"Task variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"IN hipc::Pointer data_;\nIN size_t data_size_;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Variables can be prefixed with the keywords\nIN, OUT, or INOUT."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IN"}),": This is an input."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"OUT"}),": This is an output."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"INOUT"}),": This is an input and an output."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These decorators are not required. They are simply\nempty macros. However, they help with the readability\nof your code."}),"\n",(0,t.jsx)(n.p,{children:"In our case, data_ and data_size_ are parameters\nthe user gives as input."}),"\n",(0,t.jsxs)(n.p,{children:["Why ",(0,t.jsx)(n.code,{children:"hipc::Pointer"})," instead of ",(0,t.jsx)(n.code,{children:"char *"}),"? Because\n",(0,t.jsx)(n.code,{children:"char *"})," refers to an address in the process's address\nspace. Since Chimaera runs in a different address space\nas a separate process, all pointers must be compatible\nwith shared memory. This is what ",(0,t.jsx)(n.code,{children:"hipc::Pointer"})," does.\nThis avoids a very expensive data copy."]}),"\n",(0,t.jsx)(n.h4,{id:"emplace-constructor-method-signature",children:"Emplace constructor: Method Signature"}),"\n",(0,t.jsx)(n.p,{children:"The emplace constructor for our CompressTask is below:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** Emplace constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query,\n      const hipc::Pointer &data, size_t data_size);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The emplace constructor is most important. This constructor\nshould contain all parameters to intialize the task. Every\nemplace constructor must start with the following 4 variables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const hipc::CtxAllocator<CHI_ALLOC_T> &alloc"}),": The allocator used\nto allocate this task. Automatically generated by higher-level APIs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const TaskNode &task_node"}),": The unique identifier of this task in the\nsystem. Automatically passed by higher-level APIs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const PoolId &pool_id"}),": The ChiPool this task belongs to."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const DomainQuery &dom_query"}),": The set of ChiContainers in the ChiPool\nthe task can be sent to. More discussion on domains will be later"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We then have our two custom variables that come afterwards:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"const hipc::Pointer &data"}),": The process-independent pointer to some\ndata."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"size_t data_size"}),": The total size of data."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"emplace-constructor-core-task-parameters",children:"Emplace Constructor: Core Task Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** Emplace constructor */\n  HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query,\n      const hipc::Pointer &data, size_t data_size)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kCompress;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next we look at the basic parameters being set. The main things\nthat were not described in the previous section are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"prio_"}),": The priority of this task. Can either be kLowLatency or kHighLatency.\nTasks with different priority are placed on different queues and may be executed\nout-of-order. This is a performance optimization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"method_"}),": This is the method that will process the task. Remember the ",(0,t.jsx)(n.code,{children:"compress_methods.yaml"}),"\nfile? A new file called ",(0,t.jsx)(n.code,{children:"compress_methods.h"})," was generated from that file, which is where these\nmethods are defined."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"task_flags_"}),": By default, no flags. There is another section describing the potential flags\nthat can go here -- most of which are related to performance."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"emplace-constructor-custom-parameters",children:"Emplace Constructor: Custom Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"HSHM_INLINE explicit CompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query,\n      const hipc::Pointer &data, size_t data_size)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kCompress;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n    data_ = data;\n    data_size_ = data_size;\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"The last part is the custom parameters. Not much magic here,\njust set them."}),"\n",(0,t.jsx)(n.h4,{id:"copystart",children:"CopyStart"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  void CopyStart(const CompressTask &other, bool deep) {\n    data_ = other.data_;\n    data_size_ = other.data_size_;\n    if (!deep) {\n      UnsetDataOwner();\n    }\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:'The CopyStart method is used to duplicate a task. It takes\nas input the other task (i.e., the original task) and\na parameter named "deep", which indicates how much to copy.'}),"\n",(0,t.jsx)(n.p,{children:"In general, deep is false. deep true is generally optional and\nwill likely be considered legacy / deprecated in the future.\nThis would only need to be implemented if the module developer\nneeded deep copies for their specific situation."}),"\n",(0,t.jsx)(n.p,{children:'In this example, we assume deep is always false. If deep is\nfalse, we mark this task as "not owning the data". This means\nthat when the task is eventually freed, the data pointer\nwill not be destroyed here.'}),"\n",(0,t.jsx)(n.p,{children:"Copies can happen within the networking module of chimaera.\nFor example, for replication, a task may be duplicated\nto each container it is sent to."}),"\n",(0,t.jsx)(n.h4,{id:"serializestart",children:"SerializeStart"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** (De)serialize message call */\n  template<typename Ar>\n  void SerializeStart(Ar &ar) {\n    ar.bulk(DT_WRITE, data_, data_size_);\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"This function is called by the remote_queue module of chimaera.\nIt serializes the custom parameters of the task."}),"\n",(0,t.jsx)(n.p,{children:'ar.bulk will serialize the data pointer. DT_WRITE means "I\'m writing\ndata_ of size data_size_ to the remote host".'}),"\n",(0,t.jsx)(n.h4,{id:"serializeend",children:"SerializeEnd"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** (De)serialize message return */\n  template<typename Ar>\n  void SerializeEnd(Ar &ar) {\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"This function is called when the task completes on the remote node.\nIn this case there are no return values, so this is just empty."}),"\n",(0,t.jsx)(n.h3,{id:"define-the-decompresstask",children:"Define the DecompressTask"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct DecompressTask : public Task, TaskFlags<TF_SRL_SYM> {\n  IN hipc::Pointer data_;\n  INOUT size_t data_size_;\n\n  /** SHM default constructor */\n  HSHM_INLINE explicit DecompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc)\n      : Task(alloc) {}\n\n  /** Emplace constructor */\n  HSHM_INLINE explicit DecompressTask(\n      const hipc::CtxAllocator<CHI_ALLOC_T> &alloc, const TaskNode &task_node,\n      const PoolId &pool_id, const DomainQuery &dom_query,\n      const hipc::Pointer &data, size_t data_size)\n      : Task(alloc) {\n    // Initialize task\n    task_node_ = task_node;\n    prio_ = TaskPrioOpt::kLowLatency;\n    pool_ = pool_id;\n    method_ = Method::kDecompress;\n    task_flags_.SetBits(0);\n    dom_query_ = dom_query;\n\n    // Custom\n    data_ = data;\n    data_size_ = data_size;\n  }\n\n  /** Duplicate message */\n  void CopyStart(const DecompressTask &other, bool deep) {\n    data_ = other.data_;\n    data_size_ = other.data_size_;\n    if (!deep) {\n      UnsetDataOwner();\n    }\n  }\n\n  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {\n    ar.bulk(DT_EXPOSE, data_, data_size_);\n  }\n\n  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {\n    ar.bulk(DT_WRITE, data_, data_size_);\n  }\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"The main difference here is the implementations of SerializeStart and SerializeEnd."}),"\n",(0,t.jsx)(n.h4,{id:"serializestart-1",children:"SerializeStart"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** (De)serialize message call */\n  template <typename Ar>\n  void SerializeStart(Ar &ar) {\n    ar.bulk(DT_EXPOSE, data_, data_size_);\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:'In this case, we are only "exposing" the buffer for I/O operations.\nThis means the remote node will not actually copy the data_ buffer.\nIt will just have the ability to access that buffer.'}),"\n",(0,t.jsx)(n.h4,{id:"serializeend-1",children:"SerializeEnd"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** (De)serialize message return */\n  template <typename Ar>\n  void SerializeEnd(Ar &ar) {\n    ar.bulk(DT_WRITE, data_, data_size_);\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"When the DecompressTask finishes, it will write the modified\ndata buffer back to the original host."}),"\n",(0,t.jsx)(n.h2,{id:"define-your-client-api",children:"Define your Client API"}),"\n",(0,t.jsxs)(n.p,{children:["The next file to look at is your client API: ",(0,t.jsx)(n.code,{children:"include/compressor/compressor_client.h"}),".\nFor any application that will interact with your module, this is the API that\nthey will use."]}),"\n",(0,t.jsx)(n.h3,{id:"modify-create",children:"Modify Create"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** Create a pool */\n  HSHM_INLINE_CROSS_FUN\n  void Create(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n              const DomainQuery &affinity, const chi::string &pool_name,\n              const CreateContext &ctx = CreateContext(), int compress_id = 0) {\n    FullPtr<CreateTask> task =\n        AsyncCreate(mctx, dom_query, affinity, pool_name, ctx, compress_id);\n    task->Wait();\n    Init(task->ctx_.id_);\n    CHI_CLIENT->DelTask(mctx, task);\n  }\n  CHI_TASK_METHODS(Create);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you recall, the CompressTask takes as input the type of compression to apply.\nWe add this parameter to the create method and pass as the last. ",(0,t.jsx)(n.code,{children:"AsyncCreate"}),"\ninternally constructs the ",(0,t.jsx)(n.code,{children:"CreateTaskParams"})," struct that we mentioned earlier\nin the chapter."]}),"\n",(0,t.jsx)(n.h3,{id:"modify-compress--decompress",children:"Modify Compress + Decompress"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"/** Compress task */\nvoid Compress(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n              const hipc::Pointer &data, size_t data_size) {\n  FullPtr<CompressTask> task =\n      AsyncCompress(mctx, dom_query, data, data_size);\n  task->Wait();\n  CHI_CLIENT->DelTask(mctx, task);\n}\nCHI_TASK_METHODS(Compress);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"/** Decompress task */\nvoid Decompress(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n                const hipc::Pointer &data, size_t data_size) {\n  FullPtr<DecompressTask> task =\n      AsyncDecompress(mctx, dom_query, data, data_size);\n  task->Wait();\n  CHI_CLIENT->DelTask(mctx, task);\n}\nCHI_TASK_METHODS(Decompress);\n"})}),"\n",(0,t.jsx)(n.p,{children:"We additionally pass the data and data_size parameters."}),"\n",(0,t.jsx)(n.h2,{id:"define-your-runtime-implementation",children:"Define your Runtime implementation"}),"\n",(0,t.jsxs)(n.p,{children:["The last file to consider is ",(0,t.jsx)(n.code,{children:"src/compressor_runtime.cc"}),". This file\ncontains the code that will be executed by the runtime. It holds\na class named Server. This class should always be named Server."]}),"\n",(0,t.jsx)(n.h3,{id:"modify-create-1",children:"Modify Create"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** Construct compressor */\n  void Create(CreateTask *task, RunContext &rctx) {\n    // Create a set of lanes for holding tasks\n    CreateLaneGroup(kDefaultGroup, 1, QUEUE_LOW_LATENCY);\n  }\n  void MonitorCreate(MonitorModeId mode, CreateTask *task, RunContext &rctx) {}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This method is used to effectively construct the module. The first line of this\nfile should always be CreateLaneGroup. Lanes are essentially threads. A LaneGroup\nis a set of threads that behave similarly and execute similar types of tasks.\nChange the number of lanes to potentially have more concurrency in your module."}),"\n",(0,t.jsx)(n.p,{children:"In this case, there is only one lane group -- the default group. There is only\none lane in the lane group. You can change\nthis to be separate groups. One situation is different lanes for metadata and data.\nAlternatively, different lanes for tasks that run forever vs tasks that execute\nand terminate deterministically. Generally, tasks that run forever should always\nbe mapped to a different lane than those that have a definite end."}),"\n",(0,t.jsx)(n.h3,{id:"review-maptasktolane",children:"Review MapTaskToLane"}),"\n",(0,t.jsx)(n.p,{children:"This function is what routes a task to a specific lane. In this case, the algorithm\nis fairly simple: route to the first lane."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"  /** Route a task to a lane */\n  Lane *MapTaskToLane(const Task *task) override {\n    // Route tasks to lanes based on their properties\n    // E.g., a strongly consistent filesystem could map tasks to a lane\n    // by the hash of an absolute filename path.\n    return GetLaneByHash(kDefaultGroup, task->prio_, 0);\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"More complex implementations of this could be to track the amount of\nwork each lane has to do and send tasks to lanes based on their load."}),"\n",(0,t.jsx)(n.p,{children:"Alternatively, one could send tasks to lanes depending on data dependencies.\nFor example, buckets of a key-value store could be represented as different\nlanes, and tasks for reading and writing from a bucket are stored in the same lane."}),"\n",(0,t.jsx)(n.h3,{id:"modify-decompress-and-compress",children:"Modify Decompress and Compress"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"/** The Compress method */\n  void Compress(CompressTask *task, RunContext &rctx) {\n  }\n  void MonitorCompress(MonitorModeId mode, CompressTask *task,\n                       RunContext &rctx) {\n    switch (mode) {\n      case MonitorMode::kReplicaAgg: {\n        std::vector<FullPtr<Task>> &replicas = *rctx.replicas_;\n      }\n    }\n  }\n\n  /** The Decompress method */\n  void Decompress(DecompressTask *task, RunContext &rctx) {\n  }\n  void MonitorDecompress(MonitorModeId mode, DecompressTask *task,\n                         RunContext &rctx) {\n    switch (mode) {\n      case MonitorMode::kReplicaAgg: {\n        std::vector<FullPtr<Task>> &replicas = *rctx.replicas_;\n      }\n    }\n  }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"what-are-the-monitor-methods",children:"What are the Monitor* methods?"}),"\n",(0,t.jsx)(n.p,{children:'The "Monitor*" functions (e.g., MonitorCompress) are used for handling\nevents for a specific type of task.'}),"\n",(0,t.jsxs)(n.p,{children:["One of these MonitorModes is ",(0,t.jsx)(n.code,{children:"kReplicaAgg"}),", which is an event called\nby the remote_queue for when a task was replicated -- and we are now\naggregating the results of that into a single task."]}),"\n",(0,t.jsx)(n.p,{children:"For now, we leave this as-is. The current implementation of the function\nessentially does nothing."}),"\n",(0,t.jsx)(n.h2,{id:"compile--install",children:"Compile + Install"}),"\n",(0,t.jsx)(n.p,{children:"To compile and install the module repo:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"scspkg create my_mod_repo\ncd ~/my_mod_repo\nmkdir build\ncd build\ncmake ../ -DCMAKE_INSTALL_PREFIX=$(scspkg pkg root my_mod_repo)\nmake -j32 install\n"})}),"\n",(0,t.jsx)(n.h2,{id:"invoking-your-mods",children:"Invoking your mods"}),"\n",(0,t.jsx)(n.p,{children:"In the previous example, we created the compressor mod."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "compressor/compressor_client.h"\n\nint main() {\n  CHIMAERA_CLIENT_INIT();\n  chi::compressor::Client client;\n  client.Create(\n      HSHM_MCTX,\n      chi::DomainQuery::GetDirectHash(chi::SubDomainId::kGlobalContainers, 0),\n      chi::DomainQuery::GetGlobalBcast(), "ipc_test");\n\n  size_t data_size = hshm::Unit<size_t>::Megabytes(1);\n  hipc::FullPtr<char> orig_data =\n      CHI_CLIENT->AllocateBuffer(HSHM_MCTX, data_size);\n  client.Compress(HSHM_MCTX, chi::DomainQuery::GetLocalHash(0), orig_data.shm_,\n                  data_size);\n  return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This will create the compressor module and then compress some data."}),"\n",(0,t.jsx)(n.h2,{id:"link-to-your-mods-internally",children:"Link to your mods (Internally)"}),"\n",(0,t.jsx)(n.p,{children:"Maybe you want to use your modules in the project they\nare being built (internally). Below is an example cmake."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.25)\nproject(internal)\n\nadd_executable(internal internal.cc)\ntarget_link_libraries(internal example::compressor_client)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"link-to-your-mods-externally",children:"Link to your mods (Externally)"}),"\n",(0,t.jsx)(n.p,{children:"For projects that are external to the mod repo, you\ncan link to it by finding the Example config."}),"\n",(0,t.jsx)(n.p,{children:"Below is an example CMake:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.25)\nproject(external)\n\nfind_package(Chimaera CONFIG REQUIRED)\nfind_package(Example CONFIG REQUIRED)\n\nadd_executable(external external.cc)\ntarget_link_libraries(external example::compressor_client)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"locate-your-module",children:"Locate your module"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"find_package(Example CONFIG REQUIRED)\n"})}),"\n",(0,t.jsx)(n.p,{children:'The find_package for your mod repo will be in "uppercase camel case" format\nof the repo namespace. If you recall, we created the module repo with the\nfollowing command:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"chi_make_repo ~/my_mod_repo example\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, the namespace we passed to ",(0,t.jsx)(n.code,{children:"chi_make_repo"})," is ",(0,t.jsx)(n.code,{children:"example"}),".\nSo in this case, our find_package would take as input ",(0,t.jsx)(n.code,{children:"Example"})," (the upper camel case of ",(0,t.jsx)(n.code,{children:"example"}),").\nIf the namespace were ",(0,t.jsx)(n.code,{children:"hello_example"}),", the find_package would\nbe ",(0,t.jsx)(n.code,{children:"HelloExample"})," instead."]}),"\n",(0,t.jsx)(n.h3,{id:"target-link-libraries",children:"Target link libraries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"target_link_libraries(external example::compressor_client)\n"})}),"\n",(0,t.jsx)(n.p,{children:"There are two targets that you can access here:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"example::compressor_client"}),": Contains the APIs for the client"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"example::compressor_client_gpu"}),": Contains APIs for the client,\nwhich can be called from GPU. Assumes Chimaera was compiled with\neither CUDA or ROCm."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"example::"})," prefixing the ",(0,t.jsx)(n.code,{children:"compressor_client"})," is given by the\nrepo namespace. It is in snake case. If the namespace were hello_example,\nthen it would be ",(0,t.jsx)(n.code,{children:"hello_example::compressor_client"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var a=s(96540);const t={},o=a.createContext(t);function r(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);