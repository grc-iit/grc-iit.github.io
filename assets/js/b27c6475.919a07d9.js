"use strict";(self.webpackChunkgnosis=self.webpackChunkgnosis||[]).push([[5429],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(a),d=i,h=c["".concat(s,".").concat(d)]||c[d]||u[d]||l;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,o=new Array(l);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[c]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8127:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const l={},o="Data Placement",r={unversionedId:"hermes/components/data-placement",id:"hermes/components/data-placement",title:"Data Placement",description:"Every Hermes system instance includes one or more Hermes nodes.",source:"@site/docs/03-hermes/06-components/04-data-placement.md",sourceDirName:"03-hermes/06-components",slug:"/hermes/components/data-placement",permalink:"/docs/hermes/components/data-placement",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Buffering Target",permalink:"/docs/hermes/components/buffering-target"},next:{title:"Data Staging",permalink:"/docs/hermes/components/data-staging"}},s={},p=[{value:"The Data Placement Problem",id:"the-data-placement-problem",level:2},{value:"The Data Placement Loop",id:"the-data-placement-loop",level:2},{value:"Problem to Solve in DPE",id:"problem-to-solve-in-dpe",level:2},{value:"Data Placement Solution",id:"data-placement-solution",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Data Placement Solution Implementation",id:"data-placement-solution-implementation",level:2},{value:"Experimental Setup",id:"experimental-setup",level:2},{value:"Experimental Results",id:"experimental-results",level:2},{value:"Conclusions",id:"conclusions",level:2}],m={toc:p},c="wrapper";function u(e){let{components:t,...l}=e;return(0,i.kt)(c,(0,n.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-placement"},"Data Placement"),(0,i.kt)("p",null,"Every Hermes system instance includes one or more Hermes ",(0,i.kt)("em",{parentName:"p"},"nodes"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"destination"),' is a buffering resource that can be identified by a pair\nof node + target "coordinates."'),(0,i.kt)("p",null,"Each target $",(0,i.kt)("inlineCode",{parentName:"p"},"t_k"),"$ has characteristics such as the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A capacity $",(0,i.kt)("inlineCode",{parentName:"li"},"Cap[t_k]"),"$"),(0,i.kt)("li",{parentName:"ul"},"A remaining capacity $",(0,i.kt)("inlineCode",{parentName:"li"},"Rem[t_k]"),"$"),(0,i.kt)("li",{parentName:"ul"},"A speed (or throughput) $",(0,i.kt)("inlineCode",{parentName:"li"},"Speed[...,t_k]"),"$",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This is the mean of the throughputs of all ranks associated with\nthe destination's node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Fix this","!")," Speed is really a function of the origin.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," At any point in time, there's a degree of ",(0,i.kt)("em",{parentName:"p"},"uncertainty")," to\nsome of the destination characteristics. For example, the remaining\ncapacity of a destination is typically obtained from a global metadata (MD)\nstructure that is updated asynchronously. Only the Hermes node buffer\npool managers have the precise value(s) for the pool under their\nmanagement."),(0,i.kt)("h2",{id:"the-data-placement-problem"},"The Data Placement Problem"),(0,i.kt)("p",null,"Given ",(0,i.kt)("em",{parentName:"p"},"N")," storage targets, a data placement policy ",(0,i.kt)("em",{parentName:"p"},"P"),", a cost function ",(0,i.kt)("em",{parentName:"p"},"F"),", and a ",(0,i.kt)("em",{parentName:"p"},"BLOB"),",\na data placement consists of a BLOB partitioning and an assignment of those parts to storage targets\nthat satisfies the constraints of the data placement policy and that minimizes the cost function."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Epoch - interval within which we update targets (status).",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Static (e.g., time interval or number of operations)"),(0,i.kt)("li",{parentName:"ul"},"Dynamic, i.e., computed by the delta of status")))),(0,i.kt)("p",null,"[","optional","]"," Placement window - interval within which we make data\nplacement decisions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Timer expired or I/O operation count reached, which ever comes\nfirst."),(0,i.kt)("li",{parentName:"ul"},"Static (e.g., time interval or number of operations)"),(0,i.kt)("li",{parentName:"ul"},"Dynamic, i.e., number of put operations")),(0,i.kt)("p",null,"Epoch and placement window could be aligned (static mode)."),(0,i.kt)("p",null,"The data placement is done within Data Placement Engine (DPE) component\nin HERMES."),(0,i.kt)("h2",{id:"the-data-placement-loop"},"The Data Placement Loop"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"placement schema")," $",(0,i.kt)("inlineCode",{parentName:"p"},"PS(b)"),"$ of a BLOB $",(0,i.kt)("inlineCode",{parentName:"p"},"b (>0)"),"$ is a decomposition\n$",(0,i.kt)("inlineCode",{parentName:"p"},"b = s_1+\\cdots+s_k,\\; s_i\\in\\mathbb{N}\\setminus\\{0\\}"),"$ together with a\ntarget mapping $",(0,i.kt)("inlineCode",{parentName:"p"},"(s_1,\\ldots,s_k)\\mapsto(t_1(s_1),\\ldots,t_k(s_k))"),"$."),(0,i.kt)("p",null,"A sequence of buffer IDs $",(0,i.kt)("inlineCode",{parentName:"p"},"(ID_1,\\ldots,ID_A)"),"$ ",(0,i.kt)("em",{parentName:"p"},"conforms")," to a target\nassignment $",(0,i.kt)("inlineCode",{parentName:"p"},"(s, t)"),"$, iff $",(0,i.kt)("inlineCode",{parentName:"p"},"s = \\sum_{i=1}^A Size(ID_i)"),"$ and\n$",(0,i.kt)("inlineCode",{parentName:"p"},"\\forall i\\;Target(ID_i) = t"),"$."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"allocation of a placement schema")," is a sequence of buffer IDs which\nis the concatenation of conforming target assignments."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Given: a vector of BLOBs $",(0,i.kt)("inlineCode",{parentName:"li"},"(b_1, b_2,\\ldots, b_B)"),"$"),(0,i.kt)("li",{parentName:"ol"},"The DPE creates placement schemas $",(0,i.kt)("inlineCode",{parentName:"li"},"PS(b_i),\\;1\\leq i\\leq B"),"$."),(0,i.kt)("li",{parentName:"ol"},"The placement schemas are presented to the buffer manager, which,\nfor each placement schema, returns an allocation of that schema (or\nan error), and updates the underlying metadata structures."),(0,i.kt)("li",{parentName:"ol"},"I/O clients transfer data from the BLOBs to the buffers.")),(0,i.kt)("h2",{id:"problem-to-solve-in-dpe"},"Problem to Solve in DPE"),(0,i.kt)("p",null,"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Vector of BLOBs $",(0,i.kt)("inlineCode",{parentName:"li"},"(b_1, b_2,\\ldots, b_B)"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of targets $",(0,i.kt)("inlineCode",{parentName:"li"},"(t_1, t_2,\\ldots, t_D)"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of target remaining capacities $",(0,i.kt)("inlineCode",{parentName:"li"},"Rem[t_k], \\;1\\leq k\\leq D"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of target speed $",(0,i.kt)("inlineCode",{parentName:"li"},"Speed[t_k], \\;1\\leq k\\leq D"),"$.")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Placement schema\n$",(0,i.kt)("inlineCode",{parentName:"li"},"(s_1,\\ldots,s_k)\\mapsto(t_1(s_1),\\ldots,t_k(s_k))"),"$, where\n$",(0,i.kt)("inlineCode",{parentName:"li"},"b (>0)"),"$ is a decomposition\n$",(0,i.kt)("inlineCode",{parentName:"li"},"b = s_1+\\cdots+s_k,\\; s_i\\in\\mathbb{N}\\setminus\\{0\\}"),"$")),(0,i.kt)("h2",{id:"data-placement-solution"},"Data Placement Solution"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Pick a DP solver to obtain a ",(0,i.kt)("em",{parentName:"li"},"placement schema"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Linear programming",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Constraints"),(0,i.kt)("li",{parentName:"ul"},"Objective function"))),(0,i.kt)("li",{parentName:"ul"},"Round-robin",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Granularity"))),(0,i.kt)("li",{parentName:"ul"},"Random",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Distribution(s)"))))),(0,i.kt)("li",{parentName:"ol"},'Use the buffer pool\'s "coin selector" to convert into buffer IDs.'),(0,i.kt)("li",{parentName:"ol"},"Handle two types of potential errors.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"DP solver failure: This can happen because of outdated target\nstatus, i.e., insufficient capacity, constraint infeasibility,\netc.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Solution to insufficient capacity: epoch, decision windows,\nswap space."),(0,i.kt)("li",{parentName:"ul"},"Solution to constraint infeasibility: buffer reorganization,\ntarget filtering."))),(0,i.kt)("li",{parentName:"ul"},"Coin selection failure: This can happen because of outdated\nstate view information, e.g., outdated remaining capacities.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Solution: epoch, decision windows, swap space.")))))),(0,i.kt)("h3",{id:"error-handling"},"Error Handling"),(0,i.kt)("p",null,"In both cases, the list of targets is inappropriate and needs to be\nupdated or changed."),(0,i.kt)("p",null,'The list of "relevant destinations" for a rank is assembled by the\nHermes node ',(0,i.kt)("em",{parentName:"p"},"topology generator"),'. It gets triggered when DP fails. The\ninitial topology consists of "node-local" destinations (Plan A) plus a\nbackup list of neighbors (Plan B) to consult when a rank gets in\ntrouble. If both plans fail, the topology generator invokes the\n',(0,i.kt)("em",{parentName:"p"},"application-level"),' "rebalancer" to redraw neighborhood boundaries\n(Plan C). In the past, we used to call these components node- and\napplication-level DPEs, but they aren\'t directly involved in DP\ndecisions, and we need maybe a clearer terminology.'),(0,i.kt)("h2",{id:"data-placement-solution-implementation"},"Data Placement Solution Implementation"),(0,i.kt)("p",null,"LP solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pick Google OR-Tools as a linear optimization tool to obtain\na\xa0",(0,i.kt)("em",{parentName:"li"},"placement schema"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Minimize client I/O time.")))),(0,i.kt)("p",null,"Round-robin solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pick the next ",(0,i.kt)("em",{parentName:"li"},"target")," if the remaining capacity is greater or equal\nto the BLOB size, otherwise check the one after the next target\nuntil a target with enough capacity is found.")),(0,i.kt)("p",null,"Random solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Randomly pick a target from all targets which have the capacity\ngreater or equal to the BLOB size.")),(0,i.kt)("h2",{id:"experimental-setup"},"Experimental Setup"),(0,i.kt)("p",null,"Scaling the number of BLOBs, 10 GB total BLOB size"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Small size BLOBs: random within the range of 4KB to 64KB"),(0,i.kt)("li",{parentName:"ul"},"Medium size BLOBs: random within the range of 64KB to 1MB"),(0,i.kt)("li",{parentName:"ul"},"Large size BLOBs: random within the range of 1MB to 4MB"),(0,i.kt)("li",{parentName:"ul"},"Extra large size BLOBs: random with the range 4MB to 64MB"),(0,i.kt)("li",{parentName:"ul"},"Huge size BLOBs: fixed 1GB")),(0,i.kt)("p",null,"Scaling the BLOB size, 1,000 and 8,192 BLOBs in total"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Fixed BLOB size of 4KB, 64KB, 1MB, 4MB, 64MB")),(0,i.kt)("h2",{id:"experimental-results"},"Experimental Results"),(0,i.kt)("p",null,"The DPE time of three different solvers with 10GB BLOBs in total."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(9821).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(2593).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(5935).Z,width:"360",height:"216"})),(0,i.kt)("p",null,"The associated I/O time of placement schema from three different solvers\nwith 10GB BLOBs in total."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(5140).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(5135).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(4307).Z,width:"360",height:"216"})),(0,i.kt)("p",null,"The DPE time of three different solvers with 1,000 BLOBs in total."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(2838).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(1163).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(9017).Z,width:"360",height:"216"})),(0,i.kt)("p",null,"The associated I/O time by placement schema by three different solvers\nwith 1,000 BLOBs in total."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(334).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(6996).Z,width:"360",height:"216"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(4065).Z,width:"360",height:"216"})),(0,i.kt)("h2",{id:"conclusions"},"Conclusions"),(0,i.kt)("p",null,"For a fixed total size of many BLOBs, DPE time is increasing with the\nnumber of BLOBs for all solvers."),(0,i.kt)("p",null,"Round-robin and random solver can quickly calculate targets for a BLOB\nthan LP solver, while not considering optimizing I/O time."),(0,i.kt)("p",null,"LP solver is efficient when the search space (number of targets) is not\ntoo large (for example, less than 1,024)."),(0,i.kt)("p",null,"LP solver is a good candidate to place large size BLOBs, where the DPE\ntime has less impact than the I/O time to the overall performance."),(0,i.kt)("p",null,"One of the possible policies is that size 64KB could be a boundary for\nBLOB aggregation. BLOB size less than 64KB will be aggregated within a\nplacement window and than placed together to mitigate DPE impact."),(0,i.kt)("p",null,"Another possible policy is to use round-robin or random for small blobs\nand LP solver for large blobs."))}u.isMDXComponent=!0},9821:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture1_11-39073f55ead305e54d26b2b807186055.jpg"},2593:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture2_1-f69c2af98fae3901d36a25d21d472764.jpg"},5935:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture3_1-39a88339cbe63ca25ee0724ee6299d49.jpg"},4307:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture4_1-bdcb34596dad2684fa7489a9f7f6fe79.jpg"},5135:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture5_1-7b8f1d4f1bc3d69d054d170c0f451bc6.jpg"},5140:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Picture6_1-7d429d3b8b75eaaa90a68ec6e0cd8692.jpg"},9017:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/or_dpe-ff86d9273ff956678a5c2bff993bda19.jpg"},4065:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ortools_io-2cba299e1b353b03c824eb11a917648f.jpg"},1163:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/random_dpe-11c7b726ae0dc701735a1e96486d1d1e.jpg"},6996:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/random_io-e4637d3689e4881e30360ebf78458381.jpg"},2838:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/rr_dpe-ced03cee3e9901af631e3114a92b44f0.jpg"},334:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/rr_io-e0ca102ee0c5e9e2e15303dcb58c11a1.jpg"}}]);