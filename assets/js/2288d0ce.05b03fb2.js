"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[70443],{59693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-data-structures","title":"C++ Data Structures","description":"The objective of this section is to provide an overview of the capabilities and","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/08-cpp-data-structures.mdx","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-data-structures","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-data-structures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C++ References and Pointers","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs"},"next":{"title":"Singleton","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-singleton"}}');var i=n(74848),r=n(28453);const c={},a="C++ Data Structures",o={},l=[{value:"std::vector",id:"stdvector",level:2},{value:"Construct",id:"construct",level:3},{value:"Insert and Modify",id:"insert-and-modify",level:3},{value:"Access",id:"access",level:3},{value:"Erase",id:"erase",level:3},{value:"Capacity &amp; Statistics",id:"capacity--statistics",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"std::list",id:"stdlist",level:2},{value:"Construct",id:"construct-1",level:3},{value:"Insert + Modify",id:"insert--modify",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"c-data-structures",children:"C++ Data Structures"})}),"\n",(0,i.jsx)(t.p,{children:"The objective of this section is to provide an overview of the capabilities and\nperformance characteristics of our favorite data structures. This is not a\ndocumentation page for every single container provided in C++."}),"\n",(0,i.jsx)(t.h2,{id:"stdvector",children:"std::vector"}),"\n",(0,i.jsxs)(t.p,{children:["An ",(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/vector/vector/",children:"std::vector"})," stores objects\nsequentially in memory. They are also known as dynamically-sized arrays. Unlike\ntypical arrays, vectors do not necessarily have a fixed size. We describe the\nbasic usage below. This isn't comprehensive, check the documentation for a full\nlist of features."]}),"\n",(0,i.jsx)(t.h3,{id:"construct",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to create a vector"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorConstruct() {\n  // An empty vector, no space allocated\n  std::vector<int> vec1;\n  // A vector of 100 ints, ints can be any value\n  std::vector<int> vec2(100);\n  // A vector of 100 ints, ints are initialized to 0\n  std::vector<int> vec3(100, 0);\n  // A vector of 5 ints, initialized to 0, 1, 2, 3, 4\n  std::vector<int> vec4{0, 1, 2, 3, 4};\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"insert-and-modify",children:"Insert and Modify"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to add and modify elements in a vector"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorModify() {\n  std::vector<int> vec(100);\n  // Add element to the back of a vector\n  // Size of the vector increases by 1 (now 101)\n  vec.emplace_back(2);\n  // Insert element at index 1.\n  // Size of the vector increases by 1 (now 102)\n  vec.emplace(vec.begin() + 1, 1);\n  // Modify first element of vector\n  // Size of the vector does not change (still 102)\n  vec[0] = 1;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"access",children:"Access"}),"\n",(0,i.jsx)(t.p,{children:"There are various ways to access elements of a vector:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorAccess() {\n  std::vector<int> vec(100);\n  // Get first element (operator)\n  int val1 = vec[0];\n  // Get first element (method)\n  int val2 = vec.front();\n  // Get first element (iterator)\n  std::vector<int>::iterator it3 = vec.begin();\n  int val3 = *it3;\n\n  // Get last element (operator)\n  int val4 = vec[vec.size() - 1];\n  // Get last element (method)\n  int val5 = vec.back();\n  // Get last element (iterator)\n  std::vector<int>::iterator it5 = vec.end() - 1;\n  int val6 = *it5;\n\n  // Get element at index 10 (operator)\n  int val7 = vec[10];\n  // Get element at index 10 (iterator)\n  std::vector<int>::iterator it8 = vec.begin() + 10;\n  int val8 = *it8;\n\n  // Iterate over all elements of the vector\n  for (int &val : vec) {\n      // Do something with val\n  }\n  // Iterate over all elements of the vector\n  for (auto it = vec.begin(); it != vec.end(); ++it) {\n      int &val = *it;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"erase",children:"Erase"}),"\n",(0,i.jsx)(t.p,{children:"There are a few methods to erase elements from a vector."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorErase() {\n  // Removes the element at index 2 (value 3)\n  std::vector<int> vec1{1, 2, 3, 4, 5};\n  vec1.erase(vec1.begin() + 2);\n  // Removes values 2 through 4\n  // Note, erase does NOT erase the value at vec.begin() + 4\n  std::vector<int> vec2{1, 2, 3, 4, 5};\n  vec2.erase(vec2.begin() + 1, vec2.begin() + 4);\n  // Removes all elements from the vector\n  std::vector<int> vec3{1, 2, 3, 4, 5};\n  vec3.clear();\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"capacity--statistics",children:"Capacity & Statistics"}),"\n",(0,i.jsx)(t.p,{children:"Vectors have two main statistics:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Capacity: the number of elements that can be stored in the vector"}),"\n",(0,i.jsx)(t.li,{children:"Size: the number of elements currently stored in the vector"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Capacity >= Size."}),"\n",(0,i.jsx)(t.p,{children:"To increase capacity without creating new elements, use reserve(). To increase size (i.e., add and construct elements), use resize()."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\n#include <cassert>  // for assert\nvoid TestVectorSize() {\n  std::vector<int> vec;\n  // Initially empty\n  assert(vec.size() == 0);\n  // Increase to capacity 100\n  vec.reserve(100);\n  assert(vec.size() == 0);\n  assert(vec.capacity() == 100);\n  // Add elements to the vector\n  // emplace_back is fast since there is capacity\n  vec.emplace_back(0);\n  vec.emplace_back(1);\n  assert(vec.size() == 2);\n  // Increase size to 150\n  // Capacity is not necessarily equal to 150\n  vec.resize(150);\n  assert(vec.size() == 150);\n  // Resize can be called with a smaller value\n  vec.resize(50);\n  assert(vec.size() == 50);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Operation"}),(0,i.jsx)(t.th,{children:"Runtime Complexity"}),(0,i.jsx)(t.th,{children:"Memory Complexity"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace_back"}),(0,i.jsx)(t.td,{children:"O(1) amortized. Most of the time, there will be enough capacity in the vector to avoid a reallocation. However, when the capacity is reached, a copy of the vector will be made."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). May end up creating a copy of the vector if capacity is reached."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace"}),(0,i.jsx)(t.td,{children:"O(N) since the vector will have to be shifted. It may also be copied if there's not enough capacity."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). May end up creating a copy of the vector if capacity is reached."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"accessors ([],begin,end,first,last,etc.)"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"reserve"}),(0,i.jsx)(t.td,{children:"O(1) or O(N). O(1) if new size is less than old size. Vectors will not make the data smaller, it will just store the new size. O(N) otherwise."}),(0,i.jsx)(t.td,{children:"O(1) or O(N) for the same reasons."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"resize"}),(0,i.jsx)(t.td,{children:"O(N). Will make a copy of vector if new size is larger than old size. Will erase elements from the vector if new size is smaller than new size."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). O(1) if new size is smaller than old size. O(N) otherwise."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"erase"}),(0,i.jsx)(t.td,{children:"O(N). Will shift elements after the erased value to the left."}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"size / capacity"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"When to use a vector?"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"If the number of elements is fixed or has a reasonable upper bound"}),"\n",(0,i.jsx)(t.li,{children:"You are performing many get or modify-in-place operations"}),"\n",(0,i.jsx)(t.li,{children:"It makes sense to access an element by an integer index between 0 and\nthe size of the vector"}),"\n",(0,i.jsx)(t.li,{children:"If you do not have to resize the vector often"}),"\n",(0,i.jsx)(t.li,{children:"If random access speeed is important to you"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Considerations of using a vector:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"emplace_back can be slow since it will trigger resizes eventually.\nEven though the amortized cost is O(1), it can be extremely slow\nif inserting many elements."}),"\n",(0,i.jsx)(t.li,{children:"Vectors can have very poor memory utilization if you rely too much\non the dynamic ability. To make them have an O(1) complexity, they multiply\nthe capacity of the vector by a factor. As the size of the vector grows,\nthe space waste can be pretty bad."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"stdlist",children:"std::list"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/list/list/list/",children:"std::list"})," is typically implemented as doubly-linked list. We describe the basic usage below.\nThis isn't comprehensive, check the documentation for a full list\nof features."]}),"\n",(0,i.jsx)(t.h3,{id:"construct-1",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"These are the main ways to construct a new std::list."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <list>\nvoid TestListConstruct() {\n  // An empty list\n  std::list<int> list1;\n  // A list of 100 ints, ints can be any value\n  std::list<int> list2(100);\n  // A list of 100 ints, ints are initialized to 0\n  std::list<int> list3(100, 0);\n  // A list of 5 ints, initialized to 0, 1, 2, 3, 4\n  std::list<int> list4{0, 1, 2, 3, 4};\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"insert--modify",children:"Insert + Modify"}),"\n",(0,i.jsx)(t.p,{children:"These are the main ways to insert + modify elements in an std::list."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function c(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);