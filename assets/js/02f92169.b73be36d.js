"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[99522],{75403:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/research/projects/dtio","source":"@site/src/pages/research/projects/dtio.mdx","title":"DTIO: A Data Task I/O Runtime","description":"In partnership with Argonne National Laboratory, DTIO investigates the use of a task framework for unifying complex I/O stacks and providing features such as resilience, fault-tolerance, and task replay.","frontMatter":{"title":"DTIO: A Data Task I/O Runtime"},"unlisted":false}');var n=a(74848),s=a(28453),r=a(18845);const o={title:"DTIO: A Data Task I/O Runtime"},c="DTIO: A Data Task I/O Runtime",l={},d=[{value:"Introduction: What is DTIO?",id:"introduction-what-is-dtio",level:2},{value:"Methodology",id:"methodology",level:2},{value:"Accelerated I/O Resolution Optimization",id:"accelerated-io-resolution-optimization",level:2},{value:"Data Staging and Prefetching Techniques",id:"data-staging-and-prefetching-techniques",level:2},{value:"End-to-End Results with PtychoNN Application",id:"end-to-end-results-with-ptychonn-application",level:2}];function h(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)("p",{children:(0,n.jsx)("img",{src:a(32361).A,width:"140"})}),"\n",(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"dtio-a-data-task-io-runtime",children:"DTIO: A Data Task I/O Runtime"})}),"\n",(0,n.jsx)(r.A,{projectId:"dtio"}),"\n",(0,n.jsx)(t.p,{children:"In partnership with Argonne National Laboratory, DTIO investigates the use of a task framework for unifying complex I/O stacks and providing features such as resilience, fault-tolerance, and task replay."}),"\n",(0,n.jsx)(t.h2,{id:"introduction-what-is-dtio",children:"Introduction: What is DTIO?"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Converged workflows that combine HPC, Big Data and ML tasks need to compute intermediate results and share them at large scale."}),"\n",(0,n.jsx)(t.li,{children:"HPC, Big Data Analytics, and ML feature a variety of data formats, data models, and semantics, as well as I/O libraries that implement them."}),"\n",(0,n.jsx)(t.li,{children:"These all need to interact with each other, while managing requirements with different benefits and limitations."}),"\n",(0,n.jsx)(t.li,{children:"DTIO is a scalable I/O runtime that unifies the disparate data stack for modern scientific and ML workflows."}),"\n",(0,n.jsx)(t.li,{children:"DTIO provides a DataTask Abstraction that enables transformation and unification of data formats across HPC, Big Data, and ML, as well as unique I/O pipeline optimizations."}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Insight"}),": DTIO's task-based infrastructure gives several advantages over a batch-based infrastructure, which can also apply to I/O tasks."]}),"\n",(0,n.jsx)(t.li,{children:"Improved scalability via relaxation of POSIX consistency, which allows tasks to execute faster even if it disobeys strict ordering."}),"\n",(0,n.jsx)(t.li,{children:"Improved resource utilization via constraint-based task scheduling, which allows tasks to consider load on an executor."}),"\n",(0,n.jsx)(t.li,{children:"Improved fault-tolerance via task provenance, which allows replay of tasks in the event of a fault."}),"\n",(0,n.jsx)(t.li,{children:"In addition, we aim to leverage hierarchical storage and computational storage techniques to provide an infrastructure that unifies and extends the current I/O stacks."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"methodology",children:"Methodology"}),"\n",(0,n.jsx)("center",{children:(0,n.jsx)("img",{src:a(2483).A,width:"600",alt:"dtio pipeline",title:"",class:""})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"DTIO's has a six-stage I/O processing pipeline:"}),"\n",(0,n.jsx)(t.li,{children:"(1) Applications initiate I/O requests"}),"\n",(0,n.jsx)(t.li,{children:"(2) Legacy I/O calls are intercepted and converted into DataTasks"}),"\n",(0,n.jsx)(t.li,{children:"(3) DataTasks are prepared for execution during the Task Composition stage"}),"\n",(0,n.jsx)(t.li,{children:"(4) Tasks are decomposed and queued"}),"\n",(0,n.jsx)(t.li,{children:"(5) Tasks are scheduled and assigned to executors"}),"\n",(0,n.jsx)(t.li,{children:"(6) Executors perform the I/O operations."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"accelerated-io-resolution-optimization",children:"Accelerated I/O Resolution Optimization"}),"\n",(0,n.jsx)("center",{children:(0,n.jsx)("img",{src:a(51700).A,width:"600",alt:"cache results for reads in IOR",title:"",class:""})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"DTIO implements an Accelerated I/O resolution optimization, which temporarily stores DataTasks in a circular buffer so that subsequent DataTasks can retrieve data directly from local memory."}),"\n",(0,n.jsx)(t.li,{children:"The read performance demonstrates a reduction in read time by 95.5% at 512 KiB with accelerated resolution and 64.4% reduction at 8 MiB, for an average reduction of 89.2%."}),"\n",(0,n.jsx)(t.li,{children:"The overhead for this is minimal, with a worst-case of 12% overhead on writes."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"data-staging-and-prefetching-techniques",children:"Data Staging and Prefetching Techniques"}),"\n",(0,n.jsx)("center",{children:(0,n.jsx)("img",{src:a(61692).A,width:"600",alt:"Read performance with staging and prefetching (in log scale)",title:"",class:""})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"DTIO implements a data policy that allows DataTask Executors to stage data pre-emptively before read operations arrive for it."}),"\n",(0,n.jsx)(t.li,{children:"In addition to this policy, DTIO can also send the data to the circular buffers of the clients asynchronously so that it can be accessed locally."}),"\n",(0,n.jsx)(t.li,{children:"The performance of the staging optimization shows an improvement of 88.6% over DTIO without staging. Adding the prefetching optimization to staging improves performance by a further 3.1%, total of 91.7%."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"end-to-end-results-with-ptychonn-application",children:"End-to-End Results with PtychoNN Application"}),"\n",(0,n.jsx)("center",{children:(0,n.jsx)("img",{src:a(15574).A,width:"600",alt:"PtychoNN End-to-End I/O Time: Impact of Eliminating Producer Writes with DTIO for the PtychoNN workflow.",title:"",class:""})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The PtychoNN workflow consists of a producer which reads in HDF5 data and converts it to Numpy and a consumer which reads the Numpy data as tensors. With DTIO acting as an intermediary, the producer and consumer can be run at the same time (as DTIO will allow access to partial results)."}),"\n",(0,n.jsx)(t.li,{children:"The figure shows the I/O time to run PtychoNN with and without DTIO. In this case, DTIO shows a performance improvement over PtychoNN that varies from 38% for large I/O (25.6 GiB) to 65% for smaller workloads (6.4 GiB). The average I/O performance improvement is 49.6%, or 21.6 seconds of PtychoNN's I/O time."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},18845:(e,t,a)=>{a.d(t,{A:()=>d});a(96540);var i=a(34164),n=a(46784),s=a(66188),r=a(71429),o=a(66588);const c={badgeDarker:"badgeDarker_Lm_2"};var l=a(74848);function d({addMargin:e=!0,projectId:t}){const{projects:a}=(0,o.P_)("grc-plugin-projects"),d=(0,r.G)(a,t);if(!d)return null;const{isOurs:h=!1,sourceLink:u,tutorialLink:m,type:p}=d,g="funded"===p;return g||h||u||m?(0,l.jsxs)("div",{className:(0,i.A)(e&&"margin-bottom--md"),children:[h&&(0,l.jsx)("span",{className:"badge badge--primary margin-right--xs",children:"GRC-led"}),g&&(0,l.jsx)("span",{className:"badge badge--success margin-right--xs",children:"Funded"}),void 0!==u&&(0,l.jsxs)("a",{className:(0,i.A)("badge badge--secondary margin-right--xs",c.badgeDarker),href:u,rel:"noreferrer",style:{color:"var(--ifm-color-black) !important"},target:"_blank",children:["Open Source",(0,l.jsx)(n.g,{className:"margin-left--xs",icon:s.Ju_,size:"sm",style:{color:"var(--ifm-color-black)"}})]}),void 0!==m&&(0,l.jsxs)("a",{className:"badge badge--danger margin-right--xs",href:m,rel:"noreferrer",style:{backgroundColor:"var(--ifm-color-warning-lightest) !important",borderColor:"var(--ifm-color-warning-lightest) !important",color:"var(--ifm-color-black) !important"},target:"_blank",children:["Tutorial",(0,l.jsx)(n.g,{className:"margin-left--xs",icon:s.Ju_,size:"sm",style:{color:"var(--ifm-color-black)"}})]})]}):null}},71429:(e,t,a)=>{a.d(t,{G:()=>i});const i=(e,t)=>e.find((e=>e.id===t))},2483:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/DTIO-flow-3e8caabfed5d85547738d5cd09a53666.png"},51700:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/cache-results-read-31c0ded8bd04dfd19bdf1f69500819f7.png"},32361:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/logo-9e75d71cd7192feeb44267194a9459f7.png"},15574:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/ptycho-times-10f598b3b27221547dd6328a2e46fc90.png"},61692:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/staging-results-963baf7c1c69bee84cdd3d621bbcc639.png"},28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var i=a(96540);const n={},s=i.createContext(n);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);