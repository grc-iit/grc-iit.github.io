"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[64163],{42340:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"iowarp/components/runtime/fixed-scheduling","title":"Statically Scheduling Tasks and Concurrency","description":"The section gives the overview of how to send tasks to containers in a pool.","source":"@site/docs/11-iowarp/03-components/03-runtime/07-fixed-scheduling.md","sourceDirName":"11-iowarp/03-components/03-runtime","slug":"/iowarp/components/runtime/fixed-scheduling","permalink":"/docs/iowarp/components/runtime/fixed-scheduling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Domains","permalink":"/docs/iowarp/components/runtime/domains"},"next":{"title":"Dynamic Scheduling","permalink":"/docs/iowarp/components/runtime/dynamic-scheduling"}}');var o=t(74848),i=t(28453);const s={},r="Statically Scheduling Tasks and Concurrency",c={},l=[{value:"Creating a Pool",id:"creating-a-pool",level:2},{value:"Creating a Container",id:"creating-a-container",level:2},{value:"Block Dev API Review",id:"block-dev-api-review",level:2},{value:"Spawn an Allocate task",id:"spawn-an-allocate-task",level:2},{value:"Routing Tasks to Lanes",id:"routing-tasks-to-lanes",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"statically-scheduling-tasks-and-concurrency",children:"Statically Scheduling Tasks and Concurrency"})}),"\n",(0,o.jsx)(n.p,{children:'The section gives the overview of how to send tasks to containers in a pool.\nWe go over an end-to-end flow of a block device pool and how tasks are sent\nto containers in that pool. We demonstrate "static scheduling", where the\nclient is responsible for sending the task to a particular container. We\ndiscuss "dynamic scheduling" in a future section, where the location of\nthe task is determined by an algorithm defined by the module developer.'}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-pool",children:"Creating a Pool"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'int main() {\n  chi::bdev::Client client;\n  client.Create(\n      HSHM_MCTX,\n      chi::DomainQuery::GetDirectHash(chi::SubDomain::kGlobalContainers, 0),\n      chi::DomainQuery::GetGlobalBcast(), "tempdir",\n      "fs::///tmp/chi_test_bdev.bin", GIGABYTES(1));\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Here we create the block device pool."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"chi::DomainQuery::GetDirectHash(chi::SubDomain::kGlobalContainers, 0)"}),": The admin container\nwhere the creation task is sent to. In this case, container 0."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"chi::DomainQuery::GetGlobalBcast()"}),": The set of nodes that can address the container. This\nis the set of all nodes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"tempdir"'}),": The name of the block device in iowarp."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"fs::///tmp/chi_test_bdev.bin"'}),": The name of the block device on the system. Just a file in\na filesystem."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"GIGABYTES(1)"}),": The maximum size of the file."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["This command creates a pool where containers can be migrated to any node in the entire system.\nUse ",(0,o.jsx)(n.code,{children:"GetGlobalBcast"})," for now -- smaller domains for ",(0,o.jsx)(n.code,{children:"Create"})," are not currently supported.\nThis will spawn a ",(0,o.jsx)(n.code,{children:"CreateTask"})," that gets sent to the iowarp runtime for processing."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-container",children:"Creating a Container"}),"\n",(0,o.jsxs)(n.p,{children:["Below is a snippet from the ",(0,o.jsx)(n.code,{children:"Create"})," function that gets invoked within the runtime.\nThe Pool Creation task will call the ",(0,o.jsx)(n.code,{children:"Create"})," function of the module. The creation is\nresponsible for initiating parameters to the container. The most important parameter\nwe discuss are Lanes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'  /** Construct bdev */\n  void Create(CreateTask *task, RunContext &rctx) {\n    CreateTaskParams params = task->GetParams();\n    std::string url = params.path_.str();\n    size_t dev_size = params.size_;\n    url_.Parse(url);\n    url_.path_ = hshm::Formatter::format("{}.{}", url_.path_, container_id_);\n    alloc_.Init(1, dev_size);\n    CreateLaneGroup(kMdGroup, 1, QUEUE_LOW_LATENCY);\n    CreateLaneGroup(kDataGroup, 32, QUEUE_HIGH_LATENCY);\n'})}),"\n",(0,o.jsx)(n.p,{children:"Lanes store a set of tasks to execute to process in sequence.\nThey are simply FIFO queues. The number of lanes can be thought of as the\nmaximum concurrency of a Container. Lanes will be dynamically\nmapped to worker threads based on load."}),"\n",(0,o.jsx)(n.p,{children:"Lanes get divided into different groups to logically separate tasks\nthat affect either different data structures or have very different performance\ncharacteristics. Below is an example for a block device code, where we create\ntwo groups:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"kMdGroup: where metadata-related tasks (e.g., block allocations) go"}),"\n",(0,o.jsx)(n.li,{children:"kDataGroup: where data I/O operations go"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Lane groups are set with a certain priority. Lanes\nsupport two priorities: QUEUE_LOW_LATENCY and QUEUE_HIGH_LATENCY.\nThis affects how the lanes are mapped and scheduled to workers. Generally,\nlow-latency lanes are sent to workers dedicated to a core."}),"\n",(0,o.jsx)(n.p,{children:"Additionally, each group has parameter for concurreny (number of lanes).\nIn this example, only one lane for metadata. This is because the data structure\nfor block allocation does not support concurrent access. However, the data\nobject gets 32 lanes, implying a maximum concurreny of 32 threads performing\nI/O."}),"\n",(0,o.jsx)(n.h2,{id:"block-dev-api-review",children:"Block Dev API Review"}),"\n",(0,o.jsx)(n.p,{children:"Below is a snippet of the APIs the block device exposes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"/** Allocate a section of the block device */\n  HSHM_INLINE_CROSS_FUN\n  std::vector<Block> Allocate(const hipc::MemContext &mctx,\n                              const DomainQuery &dom_query, size_t size);\n\n  /** Free a section of the block device */\n  HSHM_INLINE_CROSS_FUN\n  void Free(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n            const Block &block);\n\n  /** Write to the block device */\n  HSHM_INLINE_CROSS_FUN\n  void Write(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n             const hipc::Pointer &data, Block block);\n\n  /** Read from the block device */\n  HSHM_INLINE_CROSS_FUN\n  void Read(const hipc::MemContext &mctx, const DomainQuery &dom_query,\n            const hipc::Pointer &data, Block &block);\n"})}),"\n",(0,o.jsx)(n.p,{children:"We will discuss how a task for Allocate is mapped to the runtime."}),"\n",(0,o.jsx)(n.h2,{id:"spawn-an-allocate-task",children:"Spawn an Allocate task"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  chi::bdev::Client client;\n  // ...\n  std::vector<chi::Block> blocks =\n        client.Allocate(HSHM_MCTX,\n                        chi::DomainQuery::GetDirectHash(\n                            chi::SubDomain::kGlobalContainers, 1),\n                        MEGABYTES(1));\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is an example where we allocate 1MB of data from bdev container 1."}),"\n",(0,o.jsx)(n.h2,{id:"routing-tasks-to-lanes",children:"Routing Tasks to Lanes"}),"\n",(0,o.jsx)(n.p,{children:"When a task is mapped to a container, it must then be assigned to a lane.\nMany algorithms are possible -- it is up to the developer to implement an\nalgorithm of choice. Below is the example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"Lane *MapTaskToLane(const Task *task) override {\n    switch (task->method_) {\n      case Method::kRead:\n      case Method::kWrite: {\n        return GetLeastLoadedLane(\n            kDataGroup, task->prio_,\n            [](Load &lhs, Load &rhs) { return lhs.cpu_load_ < rhs.cpu_load_; });\n      }\n      default: {\n        return GetLaneByHash(kMdGroup, task->prio_, 0);\n      }\n    }\n  }\n"})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the read and write tasks are mapped to the kDataGroup lanes.\nThe least-loaded lane will be chosen for the mapping."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);