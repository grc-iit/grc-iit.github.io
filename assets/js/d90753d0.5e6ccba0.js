"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[4057],{30709:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-classes","title":"C++ Classes","description":"In this section, we will discuss the basics of object-oriented programming (OOP)","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/06-cpp-classes.md","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-classes","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-classes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C++ Style and Documentation","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-style-and-doc"},"next":{"title":"C++ References and Pointers","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs"}}');var r=t(74848),a=t(28453);const i={},o="C++ Classes",l={},c=[{value:"Defining a Class",id:"defining-a-class",level:2},{value:"Constructors",id:"constructors",level:2},{value:"Destructor",id:"destructor",level:2},{value:"Operator Overloading",id:"operator-overloading",level:2},{value:"Assignment Operators",id:"assignment-operators",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:3},{value:"3.6.04.3. Relational Operators",id:"36043-relational-operators",level:3},{value:"Member Access Operators",id:"member-access-operators",level:3},{value:"Function Call",id:"function-call",level:3},{value:"Bitwise Operators",id:"bitwise-operators",level:3},{value:"Principle of Least Surprise",id:"principle-of-least-surprise",level:2},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Friend Functions",id:"friend-functions",level:3},{value:"Inheritance + Virtual Methods",id:"inheritance--virtual-methods",level:2},{value:"Polymorphism",id:"polymorphism",level:2},{value:"Virtual Functions",id:"virtual-functions",level:3},{value:"Pure Virtual Functions",id:"pure-virtual-functions",level:3},{value:"Class Templates",id:"class-templates",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"c-classes",children:"C++ Classes"})}),"\n",(0,r.jsx)(n.p,{children:"In this section, we will discuss the basics of object-oriented programming (OOP)\nin C++. A class represents a set of functions (i.e., methods) and data for those\nmethods. An object is an instance of a class."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Class variables"}),"\n",(0,r.jsx)(n.li,{children:"Methods"}),"\n",(0,r.jsx)(n.li,{children:"Encapsulation:"}),"\n",(0,r.jsx)(n.li,{children:"Polymorphism"}),"\n",(0,r.jsx)(n.li,{children:"Inheritance"}),"\n",(0,r.jsx)(n.li,{children:"Operator overloading"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"defining-a-class",children:"Defining a Class"}),"\n",(0,r.jsx)(n.p,{children:"In C++, a class is a user-defined data type that combines data members (variables) and member functions (methods) into a single unit. Classes serve as blueprints for creating objects. Here's a simple example of defining a class in C++:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <iostream>\nusing namespace std;\n\nclass Rectangle {\npublic:\n    // Data members\n    double length;\n    double width;\n\n    // Member functions\n    double area() {\n        return length * width;\n    }\n\n    double perimeter() {\n        return 2 * (length + width);\n    }\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"constructors",children:"Constructors"}),"\n",(0,r.jsx)(n.p,{children:"Constructors are special member functions used to initialize objects of a class. Here's an example of a constructor for the Rectangle class:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'Rectangle::Rectangle(double l, double w) {\n    length = l;\n    width = w;\n}\n\n// Usage\nint main() {\n    Rectangle r(5.0, 3.0); // Creating a Rectangle object with specified dimensions\n    cout << "Area: " << r.area() << endl;\n    cout << "Perimeter: " << r.perimeter() << endl;\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"destructor",children:"Destructor"}),"\n",(0,r.jsx)(n.p,{children:"In C++, a destructor is a special member function that gets called when an object goes out of scope or is explicitly deleted. Here's an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'Rectangle::~Rectangle() {\n    cout << "Rectangle object destroyed" << endl;\n}\n\n// Usage\nint main() {\n    Rectangle r(5.0, 3.0);\n    // r goes out of scope here, and the destructor is called automatically\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"operator-overloading",children:"Operator Overloading"}),"\n",(0,r.jsx)(n.p,{children:"Operator overloading allows you to define how operators like +, -, *, and others behave with objects of your class. Here's an example of overloading the + operator for the Rectangle class:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'Rectangle operator+(const Rectangle& r1, const Rectangle& r2) {\n    Rectangle result;\n    result.length = r1.length + r2.length;\n    result.width = r1.width + r2.width;\n    return result;\n}\n\n// Usage\nint main() {\n    Rectangle r1(5.0, 3.0);\n    Rectangle r2(2.0, 4.0);\n    Rectangle sum = r1 + r2; // Using the overloaded + operator\n    cout << "Sum of rectangles: Area=" << sum.area() << ", Perimeter=" << sum.perimeter() << endl;\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"assignment-operators",children:"Assignment Operators"}),"\n",(0,r.jsx)(n.p,{children:"In C++, you can overload assignment operators (=, +=, -=) to define custom behavior for objects of your class during assignment. This allows you to control how your objects are copied or modified."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MyNumber {\nprivate:\n    int value;\n\npublic:\n    MyNumber(int v) : value(v) {}\n\n    // Overloading the assignment operator '='\n    MyNumber& operator=(const MyNumber& other) {\n        if (this == &other) // Self-assignment check\n            return *this;\n        \n        value = other.value;\n        return *this;\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the assignment operator to ensure that self-assignment is handled gracefully."}),"\n",(0,r.jsx)(n.h3,{id:"arithmetic-operators",children:"Arithmetic Operators"}),"\n",(0,r.jsx)(n.p,{children:"Arithmetic operators like +, -, *, /, and % can be overloaded to define custom arithmetic operations for objects of your class."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Complex {\nprivate:\n    double real;\n    double imaginary;\n\npublic:\n    Complex(double r, double i) : real(r), imaginary(i) {}\n\n    // Overloading the addition operator '+'\n    Complex operator+(const Complex& other) const {\n        return Complex(real + other.real, imaginary + other.imaginary);\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the addition operator to perform complex number addition."}),"\n",(0,r.jsx)(n.h3,{id:"36043-relational-operators",children:"3.6.04.3. Relational Operators"}),"\n",(0,r.jsxs)(n.p,{children:["Relational operators (",(0,r.jsx)(n.code,{children:"=="}),", ",(0,r.jsx)(n.code,{children:"!="}),", ",(0,r.jsx)(n.code,{children:"<"}),", ",(0,r.jsx)(n.code,{children:">"}),", ",(0,r.jsx)(n.code,{children:"<="}),", ",(0,r.jsx)(n.code,{children:">="}),") can be overloaded to define custom comparison logic for objects of your class."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Student {\nprivate:\n    int id;\n\npublic:\n    Student(int studentId) : id(studentId) {}\n\n    // Overloading the equality operator '=='\n    bool operator==(const Student& other) const {\n        return id == other.id;\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the equality operator to compare student objects based on their IDs."}),"\n",(0,r.jsx)(n.h3,{id:"member-access-operators",children:"Member Access Operators"}),"\n",(0,r.jsx)(n.p,{children:"Member access operators (-> and .) can be overloaded to customize how you access members of objects of your class."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MyString {\nprivate:\n    char* str;\n\npublic:\n    MyString(char* s) : str(s) {}\n\n    // Overloading the member access operator '->'\n    char operator[](size_t index) const {\n        return str[index];\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the member access operator to access individual characters of a string-like object."}),"\n",(0,r.jsx)(n.h3,{id:"function-call",children:"Function Call"}),"\n",(0,r.jsx)(n.p,{children:"You can overload the function call operator () to make objects of your class callable like functions."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MyFunction {\npublic:\n    int operator()(int x, int y) const {\n        return x + y;\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the function call operator to create an object that behaves like a function, adding two integers."}),"\n",(0,r.jsx)(n.h3,{id:"bitwise-operators",children:"Bitwise Operators"}),"\n",(0,r.jsxs)(n.p,{children:["Bitwise operators (",(0,r.jsx)(n.code,{children:"&"}),", ",(0,r.jsx)(n.code,{children:"|"}),", ",(0,r.jsx)(n.code,{children:"^"}),", ",(0,r.jsx)(n.code,{children:"~"}),", ",(0,r.jsx)(n.code,{children:"<<"}),", ",(0,r.jsx)(n.code,{children:">>"}),") can be overloaded to define custom bitwise operations for objects of your class."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Bitset {\nprivate:\n    unsigned int data;\n\npublic:\n    Bitset(unsigned int value) : data(value) {}\n\n    // Overloading the bitwise AND operator '&'\n    Bitset operator&(const Bitset& other) const {\n        return Bitset(data & other.data);\n    }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, we overload the bitwise AND operator to perform bitwise AND operations on bitset objects."}),"\n",(0,r.jsx)(n.p,{children:"These examples demonstrate how you can customize the behavior of operators for objects of your class, allowing you to work with them in a way that makes sense for your specific use case."}),"\n",(0,r.jsx)(n.h2,{id:"principle-of-least-surprise",children:"Principle of Least Surprise"}),"\n",(0,r.jsx)(n.p,{children:"The principle of least surprise states that components should behave the way\nthat you expect them to behave. Operator overloading can be misused and cause\nconflict when done poorly. Other languages, such as Java, do not provide\noperator overloading for this reason. There are a few common-sense methods to\nmake overloading useful:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Don't use operator overloading unless the meaning of the operator\nmatches conceptually with what is happening in the operator. For example,\ndon't overload the addition operator and then implement multiplication there."}),"\n",(0,r.jsx)(n.li,{children:"Make sure to consider the order of operations when designing your operator\noverloads. Is your operator intended to be commutative or just associative?\nWould it be intuitive and clear to someone who has never seen your code before?"}),"\n",(0,r.jsx)(n.li,{children:"It should be intuitive and clear what data types the operator accepts.\nIt shouldn't require the user to go to documentation every single time to\ncheck if the operator is valid for a certain combination of types."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,r.jsx)(n.p,{children:"Encapsulation is the idea that the class should expose only the methods and\ndata that the user needs to see. It reduces the amount of mistakes that users\ncan make when using your code. It's also easier to read a codebase when you\nhave fewer methods to look at and understand."}),"\n",(0,r.jsxs)(n.p,{children:["Encapsulation is provided using ",(0,r.jsx)(n.em,{children:"access specifiers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"public"}),": The method or data can be called outside of the class"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"private"}),": The method or data cannot be called outside of the class"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"protected"}),": The method or data cannot be called outside of the class,\nbut it can be called by derived classes."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"friend-functions",children:"Friend Functions"}),"\n",(0,r.jsx)(n.p,{children:'Friend functions can be used to break encapsulation in particular cases.\nBy declaring a function as "friend" that function can access private and protected\nmembers of a certain class. A practical example of this is with C++ iterators,\nwhich may call specific methods of the class being iterated over.'}),"\n",(0,r.jsxs)(n.p,{children:["Below is an example demonstrating how we can giv the function ",(0,r.jsx)(n.code,{children:"friendFunction"}),"\naccess to the private class variable ",(0,r.jsx)(n.code,{children:"data"})," in ",(0,r.jsx)(n.code,{children:"MyFunction"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MyClass {\nprivate:\n    int data;\n\npublic:\n    MyClass(int d) : data(d) {}\n\n    // Declare a friend function\n    friend void friendFunction(MyClass& obj);\n};\n\n// Define the friend function\nvoid friendFunction(MyClass& obj) {\n    obj.data = 99; // Access private member of MyClass\n}\n\n// Usage\nint main() {\n    MyClass obj(42);\n    friendFunction(obj); // Calls the friend function to modify obj's private member\n    return 0;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"inheritance--virtual-methods",children:"Inheritance + Virtual Methods"}),"\n",(0,r.jsx)(n.p,{children:'One of the most important principles in OOP is "Do Not Repeat Yourself" (DRY).\nOne way to accomplish this is through inheritance.'}),"\n",(0,r.jsx)(n.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,r.jsx)(n.p,{children:"Polymorphism is a fundamental concept in object-oriented programming that allows objects of different classes to be treated as objects of a common base class. This enables you to write more generic code that can work with a variety of objects. In C++, polymorphism is achieved through the use of virtual functions and inheritance."}),"\n",(0,r.jsx)(n.h3,{id:"virtual-functions",children:"Virtual Functions"}),"\n",(0,r.jsx)(n.p,{children:'In C++, you can define a function in a base class as "virtual." Virtual functions provide a mechanism for dynamic method dispatch, allowing the appropriate derived class\'s implementation to be called at runtime, based on the actual object type. This feature is crucial for achieving runtime polymorphism.'}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Shape {\npublic:\n    virtual double area() const = 0; // Pure virtual function\n};\n\nclass Circle : public Shape {\nprivate:\n    double radius;\n\npublic:\n    Circle(double r) : radius(r) {}\n\n    double area() const override {\n        return 3.14159265359 * radius * radius;\n    }\n};\n\nclass Rectangle : public Shape {\nprivate:\n    double length;\n    double width;\n\npublic:\n    Rectangle(double l, double w) : length(l), width(w) {}\n\n    double area() const override {\n        return length * width;\n    }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pure-virtual-functions",children:"Pure Virtual Functions"}),"\n",(0,r.jsx)(n.p,{children:"A pure virtual function is a virtual function declared in a base class but without an implementation. Derived classes must provide an implementation for pure virtual functions. This concept is used to create abstract base classes, which cannot be instantiated themselves but serve as a common interface for derived classes."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Shape {\npublic:\n    virtual double area() const = 0; // Pure virtual function\n};\n\nclass Circle : public Shape {\nprivate:\n    double radius;\n\npublic:\n    Circle(double r) : radius(r) {}\n\n    double area() const override {\n        return 3.14159265359 * radius * radius;\n    }\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"class-templates",children:"Class Templates"}),"\n",(0,r.jsx)(n.p,{children:"Class templates in C++ allow you to define generic classes that can work with\ndifferent data types. They are a powerful feature for creating reusable\nand type-safe code."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nclass Pair {\nprivate:\n    T first;\n    T second;\n\npublic:\n    Pair(T f, T s) : first(f), second(s) {}\n\n    T getFirst() const {\n        return first;\n    }\n\n    T getSecond() const {\n        return second;\n    }\n};\n\n// Usage\nint main() {\n    Pair<int> intPair(1, 2);\n    Pair<double> doublePair(3.14, 2.71);\n    return 0;\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);