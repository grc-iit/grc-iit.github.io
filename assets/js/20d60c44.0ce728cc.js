"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[228],{58404:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"iowarp/components/runtime/dynamic-scheduling","title":"Dynamic Scheduling","description":"Continuing from the previous example, we now describe Dynamic Scheduling.","source":"@site/docs/11-iowarp/03-components/03-runtime/08-dynamic-scheduling.md","sourceDirName":"11-iowarp/03-components/03-runtime","slug":"/iowarp/components/runtime/dynamic-scheduling","permalink":"/docs/iowarp/components/runtime/dynamic-scheduling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Statically Scheduling Tasks and Concurrency","permalink":"/docs/iowarp/components/runtime/fixed-scheduling"},"next":{"title":"Long-Running Tasks","permalink":"/docs/iowarp/components/runtime/long-running"}}');var a=t(74848),i=t(28453);const s={},c="Dynamic Scheduling",r={},l=[{value:"Spawn an Allocate task",id:"spawn-an-allocate-task",level:2},{value:"The Monitor Callback",id:"the-monitor-callback",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"dynamic-scheduling",children:"Dynamic Scheduling"})}),"\n",(0,a.jsx)(n.p,{children:"Continuing from the previous example, we now describe Dynamic Scheduling.\nIn this case, users do not provide the exact container they want the task\nto be mapped to. Instead, the pool provides a scheduling algorithm that\ndetermines where the task should go."}),"\n",(0,a.jsx)(n.h2,{id:"spawn-an-allocate-task",children:"Spawn an Allocate task"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  chi::bdev::Client client;\n  // ...\n  std::vector<chi::Block> blocks =\n        client.Allocate(HSHM_MCTX,\n                        chi::DomainQuery::GetDynamic(),\n                        MEGABYTES(1));\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is an example where we allocate 1MB of data from the pool dynamically."}),"\n",(0,a.jsx)(n.h2,{id:"the-monitor-callback",children:"The Monitor Callback"}),"\n",(0,a.jsx)(n.p,{children:"Each task has a Monitor function associated with it. Below is an example\nof how it is can be used for dynamic scheduling callbacks."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"  template <typename TaskT>\n  void IoRoute(TaskT *task) {\n    // Concretize the domain to map the task\n    task->dom_query_ = chi::DomainQuery::GetDirectHash(\n        chi::SubDomainId::kGlobalContainers, 0);\n    task->SetDirect();\n    task->UnsetRouted();\n  }\n\n\n  void MonitorWrite(MonitorModeId mode, WriteTask *task, RunContext &rctx) {\n    switch (mode) {\n      case MonitorMode::kSchedule: {\n        IoRoute<WriteTask>(task);\n        return;\n      }\n    }\n  }\n"})}),"\n",(0,a.jsx)(n.p,{children:"This function simply converts the task's domain to always route to container 0.\nBetter algorithms can be made. For every task that should support dynamic scheduling,\na code snippet like this should be added to their Monitor function. For example,\nfor Reads, you should update MonitorRead."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var o=t(96540);const a={},i=o.createContext(a);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);