"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[58270],{76292:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"wisio/tools","title":"Tools","description":"This page provides an overview of the supplementary tools distributed with WisIO.","source":"@site/docs/30-wisio/04-tools.md","sourceDirName":"30-wisio","slug":"/wisio/tools","permalink":"/docs/wisio/tools","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/docs/wisio/configuration"},"next":{"title":"Introduction","permalink":"/docs/jarvis/jarvis-util/index"}}');var n=r(74848),d=r(28453);const s={},c="Tools",l={},o=[{value:"<code>wisio-recorder2parquet</code>",id:"wisio-recorder2parquet",level:2},{value:"Functionality",id:"functionality",level:3},{value:"Usage",id:"usage",level:3}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"tools",children:"Tools"})}),"\n",(0,n.jsx)(t.p,{children:"This page provides an overview of the supplementary tools distributed with WisIO."}),"\n",(0,n.jsx)(t.h2,{id:"wisio-recorder2parquet",children:(0,n.jsx)(t.code,{children:"wisio-recorder2parquet"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"wisio-recorder2parquet"})," tool is a command-line utility designed to convert I/O trace files generated by the Recorder tracing tool into the Apache Parquet format. This conversion is beneficial for efficient storage and subsequent analysis, as Parquet is a columnar storage format optimized for analytical workloads."]}),"\n",(0,n.jsx)(t.h3,{id:"functionality",children:"Functionality"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Input:"})," Takes raw trace files generated by the Recorder tool. These files typically contain detailed records of I/O operations performed by an application."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Processing:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Parses individual trace records, extracting information such as function calls (e.g., ",(0,n.jsx)(t.code,{children:"open"}),", ",(0,n.jsx)(t.code,{children:"read"}),", ",(0,n.jsx)(t.code,{children:"write"}),", POSIX I/O, MPI I/O calls), timestamps, file identifiers, process/rank information, and data transfer sizes."]}),"\n",(0,n.jsx)(t.li,{children:"Categorizes I/O operations (e.g., read, write, metadata)."}),"\n",(0,n.jsx)(t.li,{children:"Extracts metadata from the input trace file paths, such as hostname, application name, and process ID."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Output:"})," Generates Parquet files containing the structured I/O trace data. The schema of the Parquet files includes the following fields:"]}),"\n"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field Name"}),(0,n.jsx)(t.th,{children:"Data Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"index"})}),(0,n.jsx)(t.td,{children:"Int64"}),(0,n.jsx)(t.td,{children:"Record index"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"level"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"Call stack level (if available)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"tstart"})}),(0,n.jsx)(t.td,{children:"Float32"}),(0,n.jsx)(t.td,{children:"Start timestamp"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"tmid"})}),(0,n.jsx)(t.td,{children:"Int64"}),(0,n.jsx)(t.td,{children:"Timestamp midpoint"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"tend"})}),(0,n.jsx)(t.td,{children:"Float32"}),(0,n.jsx)(t.td,{children:"End timestamp"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"duration"})}),(0,n.jsx)(t.td,{children:"Float32"}),(0,n.jsx)(t.td,{children:"Duration of the operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hostname"})}),(0,n.jsx)(t.td,{children:"UTF8 String"}),(0,n.jsx)(t.td,{children:"Hostname where the operation occurred"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"app"})}),(0,n.jsx)(t.td,{children:"UTF8 String"}),(0,n.jsx)(t.td,{children:"Application name"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"rank"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"MPI rank"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"proc_name"})}),(0,n.jsx)(t.td,{children:"UTF8 String"}),(0,n.jsx)(t.td,{children:"Process name"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"proc_id"})}),(0,n.jsx)(t.td,{children:"Int64"}),(0,n.jsx)(t.td,{children:"Unique process identifier"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"thread_id"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"Thread identifier"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"cat"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"Operation category"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"io_cat"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"I/O category (Read, Write, Metadata)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"func_id"})}),(0,n.jsx)(t.td,{children:"UTF8 String"}),(0,n.jsx)(t.td,{children:"Function name/identifier"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"acc_pat"})}),(0,n.jsx)(t.td,{children:"Int32"}),(0,n.jsx)(t.td,{children:"Access pattern (e.g., sequential, random)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"file_id"})}),(0,n.jsx)(t.td,{children:"Int64"}),(0,n.jsx)(t.td,{children:"Unique file identifier"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"file_name"})}),(0,n.jsx)(t.td,{children:"UTF8 String"}),(0,n.jsx)(t.td,{children:"Name of the file involved in the operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"size"})}),(0,n.jsx)(t.td,{children:"Int64"}),(0,n.jsx)(t.td,{children:"Size of the I/O operation (bytes)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"bandwidth"})}),(0,n.jsx)(t.td,{children:"Float32"}),(0,n.jsx)(t.td,{children:"Calculated bandwidth for the operation"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"usage",children:"Usage"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"wisio-recorder2parquet"})," tool is typically built as part of the WisIO project, specifically within the ",(0,n.jsx)(t.code,{children:"recorder"})," subproject. Its direct usage involves invoking the compiled executable with the path to the Recorder trace files."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"mpirun -n 8 wisio-recorder2parquet <input_recorder_trace_directory>\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The tool processes the traces from the specified ",(0,n.jsx)(t.code,{children:"<input_recorder_trace_directory>"}),". It outputs one or more ",(0,n.jsx)(t.code,{children:".parquet"})," files into a subdirectory named ",(0,n.jsx)(t.code,{children:"_parquet"}),", which is automatically created within the ",(0,n.jsx)(t.code,{children:"<input_recorder_trace_directory>"}),". These resulting Parquet files can then be used as input for the WisIO ",(0,n.jsx)(t.code,{children:"recorder"})," analyzer."]})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>c});var i=r(96540);const n={},d=i.createContext(n);function s(e){const t=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(d.Provider,{value:t},e.children)}}}]);