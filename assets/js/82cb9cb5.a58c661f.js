"use strict";(self.webpackChunkgnosis=self.webpackChunkgnosis||[]).push([[527],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var a=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(r),d=i,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||n;return r?a.createElement(h,l(l({ref:t},p),{},{components:r})):a.createElement(h,l({ref:t},p))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,l=new Array(n);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var u=2;u<n;u++)l[u]=r[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},1158:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>n,metadata:()=>o,toc:()=>u});var a=r(7462),i=(r(7294),r(3905));const n={},l="Buffer Organizer",o={unversionedId:"hermes/components/buffer-organizer",id:"hermes/components/buffer-organizer",title:"Buffer Organizer",description:'The Buffer Organizer is the "corrector" half of our',source:"@site/docs/03-hermes/06-components/01-buffer-organizer.md",sourceDirName:"03-hermes/06-components",slug:"/hermes/components/buffer-organizer",permalink:"/docs/hermes/components/buffer-organizer",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Programming",permalink:"/docs/hermes/programming"},next:{title:"Buffer Pool",permalink:"/docs/hermes/components/buffer-pool"}},s={},u=[{value:"Objectives",id:"objectives",level:2},{value:"Blob Scoring",id:"blob-scoring",level:2},{value:"Importance Score",id:"importance-score",level:3},{value:"Variables that might contribute to the importance score",id:"variables-that-might-contribute-to-the-importance-score",level:4},{value:"Access Score",id:"access-score",level:3},{value:"Variables that contribute to the access score",id:"variables-that-contribute-to-the-access-score",level:4},{value:"How the scores are used",id:"how-the-scores-are-used",level:3},{value:"Ideas",id:"ideas",level:2},{value:"Operations",id:"operations",level:2},{value:"Transfer",id:"transfer",level:3},{value:"Who can initiate Transfer tasks?",id:"who-can-initiate-transfer-tasks",level:4},{value:"Evict(size_t bytes, Targets[])",id:"evictsize_t-bytes-targets",level:3},{value:"Who can initiate Eviction tasks?",id:"who-can-initiate-eviction-tasks",level:4},{value:"Who translates an Eviction into a series of Transfers?",id:"who-translates-an-eviction-into-a-series-of-transfers",level:4},{value:"Single shared file pros",id:"single-shared-file-pros",level:4},{value:"File per rank pros",id:"file-per-rank-pros",level:4},{value:"File per node",id:"file-per-node",level:4},{value:"Triggers",id:"triggers",level:2},{value:"Periodic",id:"periodic",level:3},{value:"Client-triggered",id:"client-triggered",level:3},{value:"System-triggered",id:"system-triggered",level:3},{value:"Requirements for Queue implementation",id:"requirements-for-queue-implementation",level:3},{value:"Design Details",id:"design-details",level:2},{value:"BO RPC Server",id:"bo-rpc-server",level:3},{value:"Buffer Organizer",id:"buffer-organizer-1",level:3},{value:"Work Queues",id:"work-queues",level:4},{value:"Schedulers",id:"schedulers",level:4},{value:"Threads",id:"threads",level:4},{value:"Example Flows",id:"example-flows",level:2},{value:"Hot Put",id:"hot-put",level:3},{value:"BO Eviction Flow",id:"bo-eviction-flow",level:3},{value:"Ideas",id:"ideas-1",level:2},{value:"Experiments",id:"experiments",level:2}],p={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"buffer-organizer"},"Buffer Organizer"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"Buffer Organizer"),' is the "corrector" half of our\npredictor/corrector model. It attempts to correct sub-optimal DPE\nplacements by moving data among buffers.'),(0,i.kt)("h2",{id:"objectives"},"Objectives"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Management of hierarchical buffering space",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Data flushing"),(0,i.kt)("li",{parentName:"ul"},"Read acceleration"))),(0,i.kt)("li",{parentName:"ul"},"Manage data life cycle, or journey",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When is the blob in equilibrium?"),(0,i.kt)("li",{parentName:"ul"},"How do we eliminate unnecessary data movement?")))),(0,i.kt)("h2",{id:"blob-scoring"},"Blob Scoring"),(0,i.kt)("p",null,"We attempt to meet the above objectives via a ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," scoring system. Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," has two different scores associated with it: the ",(0,i.kt)("strong",{parentName:"p"},"importance score")," and the ",(0,i.kt)("strong",{parentName:"p"},"access score"),"."),(0,i.kt)("h3",{id:"importance-score"},"Importance Score"),(0,i.kt)("p",null,"The importance score is a real number in the range ","[0, 1]"," where 0 represents a ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," that is not important to the user (i.e., it will not be accessed) and 1 represents a ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," that will be accessed either very frequently, very soon, or both."),(0,i.kt)("h4",{id:"variables-that-might-contribute-to-the-importance-score"},"Variables that might contribute to the importance score"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Blob Size"),(0,i.kt)("li",{parentName:"ul"},"Blob Name"),(0,i.kt)("li",{parentName:"ul"},"Recency of Blob access"),(0,i.kt)("li",{parentName:"ul"},"Frequency of Blob access"),(0,i.kt)("li",{parentName:"ul"},"User-supplied priority (this is only a hint, not a guarantee).")),(0,i.kt)("h3",{id:"access-score"},"Access Score"),(0,i.kt)("p",null,"This is a real number in the range ","[0, 1]"," where 0 represents a ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," with the slowest access time (i.e., all its ",(0,i.kt)("inlineCode",{parentName:"p"},"Buffer"),"s are in the slowest tier) and 1 represents a ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob")," with the quickest access time (all the ",(0,i.kt)("inlineCode",{parentName:"p"},"Buffer"),"s are in the fastest tier)."),(0,i.kt)("h4",{id:"variables-that-contribute-to-the-access-score"},"Variables that contribute to the access score"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Bandwidth of the tiers that contain the ",(0,i.kt)("inlineCode",{parentName:"li"},"Blob"),"'s ",(0,i.kt)("inlineCode",{parentName:"li"},"Buffer"),"s."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"Blob")," distribution (i.e., is all the data in a single ",(0,i.kt)("inlineCode",{parentName:"li"},"Buffer"),", or is it spread out among multiple ",(0,i.kt)("inlineCode",{parentName:"li"},"Buffer"),"s on multiple nodes?).")),(0,i.kt)("h3",{id:"how-the-scores-are-used"},"How the scores are used"),(0,i.kt)("p",null,"The goal of the ",(0,i.kt)("inlineCode",{parentName:"p"},"BufferOrganizer")," is to ensure that each ",(0,i.kt)("inlineCode",{parentName:"p"},"Blob"),"'s access score is closely aligned to its importance score."),(0,i.kt)("h2",{id:"ideas"},"Ideas"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If a ",(0,i.kt)("inlineCode",{parentName:"li"},"Blob"),"'s ",(0,i.kt)("inlineCode",{parentName:"li"},"Bucket")," has a reference count of 0 (i.e., no process has an open handle to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Bucket"),") then the importance score should be 0. The score is only calculated once at least one process opens the ",(0,i.kt)("inlineCode",{parentName:"li"},"Bucket"),".")),(0,i.kt)("h2",{id:"operations"},"Operations"),(0,i.kt)("p",null,"All ",(0,i.kt)("inlineCode",{parentName:"p"},"BufferOrganizer")," operations are implemented in terms of 3 simple\noperators"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"MOVE(BufferID, TargetID)"),(0,i.kt)("li",{parentName:"ul"},"COPY(BufferID, TargetID)"),(0,i.kt)("li",{parentName:"ul"},"DELETE(BufferID)")),(0,i.kt)("p",null,"With these operators, we can build more complex tasks:"),(0,i.kt)("h3",{id:"transfer"},"Transfer"),(0,i.kt)("p",null,"Move a ",(0,i.kt)("inlineCode",{parentName:"p"},"BufferID")," from one set of ",(0,i.kt)("inlineCode",{parentName:"p"},"Target"),"s to another."),(0,i.kt)("h4",{id:"who-can-initiate-transfer-tasks"},"Who can initiate Transfer tasks?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The System (load balancing)"),(0,i.kt)("li",{parentName:"ul"},"The User (producer/consumer)")),(0,i.kt)("h3",{id:"evictsize_t-bytes-targets"},"Evict(size_t bytes, Targets","[","]",")"),(0,i.kt)("p",null,"Move a set of ",(0,i.kt)("inlineCode",{parentName:"p"},"BufferId"),"s from one set of ",(0,i.kt)("inlineCode",{parentName:"p"},"Target"),"s to an unspecified\nlocation (could even be swap space)."),(0,i.kt)("h4",{id:"who-can-initiate-eviction-tasks"},"Who can initiate Eviction tasks?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Put (DPE)"),(0,i.kt)("li",{parentName:"ul"},"Get (Prefetcher)"),(0,i.kt)("li",{parentName:"ul"},"Thread that updates the ",(0,i.kt)("inlineCode",{parentName:"li"},"SystemViewState")," (enforces a minimum\ncapacity threshold passed in through the config).")),(0,i.kt)("h4",{id:"who-translates-an-eviction-into-a-series-of-transfers"},"Who translates an Eviction into a series of Transfers?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DPE?"),(0,i.kt)("li",{parentName:"ul"},"BO?")),(0,i.kt)("h4",{id:"single-shared-file-pros"},"Single shared file pros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Could theoretically reap performance benefits of collective IO\noperations, although I don't think we'll ever be able to capitalize\non this because each rank must act independently and can't\nsynchronize with the other ranks."),(0,i.kt)("li",{parentName:"ul"},"Less stress on the PFS metadata server.")),(0,i.kt)("h4",{id:"file-per-rank-pros"},"File per rank pros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Don't have to worry about reserving size for each rank."),(0,i.kt)("li",{parentName:"ul"},"Don't have to worry about locking.")),(0,i.kt)("h4",{id:"file-per-node"},"File per node"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We'll go with this for the initial implementation."),(0,i.kt)("li",{parentName:"ul"},"Don't have to worry about locking or reserving size with respect to\nthe buffer organizer. However, since multiple ranks could\npotentially write to the same swap file, we need to either",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Filter all swap traffic through the buffer organizer"),(0,i.kt)("li",{parentName:"ul"},"Synchronize all access to the file"))),(0,i.kt)("li",{parentName:"ul"},"Won't overload the metadata servers as bad as file per rank.")),(0,i.kt)("h2",{id:"triggers"},"Triggers"),(0,i.kt)("p",null,"The Buffer Organizer can be triggered in 3 ways:"),(0,i.kt)("h3",{id:"periodic"},"Periodic"),(0,i.kt)("p",null,"The period can be controlled by a configuration variable."),(0,i.kt)("h3",{id:"client-triggered"},"Client-triggered"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If, for any reason, a client DPE places data to the swap target, it\nwill also trigger the buffer organizer by adding an event to the\nbuffer organizer's queue."),(0,i.kt)("li",{parentName:"ul"},"We store the blob name, the offset into the swap target (for\nfile-based targets), and the blob size."),(0,i.kt)("li",{parentName:"ul"},"When the buffer organizer processes an event, it")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Reads the blob from the swap target into memory."),(0,i.kt)("li",{parentName:"ol"},"Calls ",(0,i.kt)("inlineCode",{parentName:"li"},"Put")," to place the blob into the hierarchy. If the ",(0,i.kt)("inlineCode",{parentName:"li"},"Put"),"\nfails, it tries again, up to ",(0,i.kt)("inlineCode",{parentName:"li"},"num_buffer_organizer_retries"),"\n(configurable) times.")),(0,i.kt)("h3",{id:"system-triggered"},"System-triggered"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Nothing is implemented yet."),(0,i.kt)("li",{parentName:"ul"},"Should the BO constantly monitor the buffering hierarchy and attempt\nto maintain a set of rules (remaining capacity percentage,\nthresholds, etc.)?"),(0,i.kt)("li",{parentName:"ul"},'Should the BO simply carry out "orders" and not attempt to make its\nown decisions? If so, who gives the orders?'),(0,i.kt)("li",{parentName:"ul"},"Should the BO be available for other asynchronous tasks?")),(0,i.kt)("h3",{id:"requirements-for-queue-implementation"},"Requirements for Queue implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(At least) 2 different priority lanes"),(0,i.kt)("li",{parentName:"ul"},"Node local and remote queues (but only for neighborhoods, not global\nqueues)."),(0,i.kt)("li",{parentName:"ul"},"Need ability to restrict queue length")),(0,i.kt)("h2",{id:"design-details"},"Design Details"),(0,i.kt)("h3",{id:"bo-rpc-server"},"BO RPC Server"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"RPC is used to route ",(0,i.kt)("inlineCode",{parentName:"li"},"BoTask"),"s to the appropriate Hermes core.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"BO")," RPC server only has one function:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool EnqueueBoTask(BoTask task, Priority priority);\n")))),(0,i.kt)("p",null,"[","[../images/bo_rpc.png]","]"),(0,i.kt)("h3",{id:"buffer-organizer-1"},"Buffer Organizer"),(0,i.kt)("h4",{id:"work-queues"},"Work Queues"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Argobots ",(0,i.kt)("strong",{parentName:"li"},"pool"),"s"),(0,i.kt)("li",{parentName:"ul"},"High and low priorities"),(0,i.kt)("li",{parentName:"ul"},"Basic FIFO queue by default"),(0,i.kt)("li",{parentName:"ul"},"Completely customizable (e.g., could be a priority queue, min-heap,\netc.)")),(0,i.kt)("h4",{id:"schedulers"},"Schedulers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Argobots ",(0,i.kt)("strong",{parentName:"li"},"scheduler"),"s"),(0,i.kt)("li",{parentName:"ul"},"Takes tasks from the queues and runs them on OS threads as user\nlevel threads (basically coroutines)."),(0,i.kt)("li",{parentName:"ul"},"Completely customizable."),(0,i.kt)("li",{parentName:"ul"},"By default, one scheduler is associated with a single execution\nstream (OS thread)."),(0,i.kt)("li",{parentName:"ul"},"Only take tasks from low priority queue if high priority queue is\nempty?")),(0,i.kt)("h4",{id:"threads"},"Threads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Argobots ",(0,i.kt)("strong",{parentName:"li"},"execution stream"),"s"),(0,i.kt)("li",{parentName:"ul"},"Bound to a ",(0,i.kt)("strong",{parentName:"li"},"processing element")," (CPU core or hyperthread), and\nshouldn't be oversubscribed.")),(0,i.kt)("p",null,(0,i.kt)("img",{src:r(5181).Z,width:"643",height:"495"})),(0,i.kt)("h2",{id:"example-flows"},"Example Flows"),(0,i.kt)("h3",{id:"hot-put"},"Hot Put"),(0,i.kt)("p",null,(0,i.kt)("img",{src:r(8418).Z,width:"378",height:"956"})),(0,i.kt)("h3",{id:"bo-eviction-flow"},"BO Eviction Flow"),(0,i.kt)("p",null,(0,i.kt)("img",{src:r(1506).Z,width:"553",height:"524"})),(0,i.kt)("h2",{id:"ideas-1"},"Ideas"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An importance score of 0 could be the signal to flush a ",(0,i.kt)("inlineCode",{parentName:"li"},"Blob")," to the PFS."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"StageIn")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"StageOut")," APIs"),(0,i.kt)("li",{parentName:"ul"},'Reverse "gravity" for read heavy workloads. ',(0,i.kt)("inlineCode",{parentName:"li"},"Blobs")," trickle up to higher tiers."),(0,i.kt)("li",{parentName:"ul"},"Explicitly maintain Target capacity thresholds."),(0,i.kt)("li",{parentName:"ul"},"Introduce horizontal movement if Topology threshold is exceeded.")),(0,i.kt)("h2",{id:"experiments"},"Experiments"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Test the difference between flushing tier by tier vs skipping tiers. For example, a ",(0,i.kt)("inlineCode",{parentName:"li"},"Blob")," moving from RAM to burst buffer could go through NVMe as an intermediate tier, or skip it altogether.")))}m.isMDXComponent=!0},5181:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/bo-9412e1ce05035896279ca164b1375068.png"},1506:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/bo_evict-f585db845536915d3efa4b9225efce29.png"},8418:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/hot_put-0d2d32fadedf6f594a46ecc415ad16d0.png"}}]);