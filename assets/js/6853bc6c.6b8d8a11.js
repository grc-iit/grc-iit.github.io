"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[9548],{6918:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=t(5893),a=t(1151);const s={},o="Singleton",l={id:"hpc-tutorials/cpp-introduction/cpp-singleton",title:"Singleton",description:"A singleton is used to provide a single instance of a class and a way",source:"@site/docs/02-hpc-tutorials/04-cpp-introduction/09-cpp-singleton.md",sourceDirName:"02-hpc-tutorials/04-cpp-introduction",slug:"/hpc-tutorials/cpp-introduction/cpp-singleton",permalink:"/docs/hpc-tutorials/cpp-introduction/cpp-singleton",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"C++ Data Structures",permalink:"/docs/hpc-tutorials/cpp-introduction/cpp-data-structures"},next:{title:"Factory Design Pattern",permalink:"/docs/hpc-tutorials/cpp-introduction/cpp-factory"}},r={},c=[{value:"Usage Example",id:"usage-example",level:2},{value:"Easy Singleton",id:"easy-singleton",level:2},{value:"Singleton",id:"singleton-1",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"singleton",children:"Singleton"}),"\n",(0,i.jsx)(n.p,{children:"A singleton is used to provide a single instance of a class and a way\nto access that object from any method. This case\ncomes up pretty frequently in our research."}),"\n",(0,i.jsx)(n.p,{children:"We often use singletons to store configuration data. For example, storage systems and databases such as OrangeFS, Redis, and MongoDB, have configuration files. These files may be in XML, YAML, JSON etc. Often times, it is helpful to store the information from these files in a Singleton. We typically call this a ConfigurationManager."}),"\n",(0,i.jsx)(n.p,{children:"Singletons are intended to be created once and then destroyed at the end of the program. They are similar to global variables -- except they are much\nmore readable. The main benefit of the singleton pattern is that you avoid passing a reference to the singleton data to every single function, class, and method. It helps reduce code duplication and the complexity of function parameter lists."}),"\n",(0,i.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,i.jsx)(n.p,{children:"First, we'll give a brief example of the singleton pattern."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include "easy_singleton.h"\n\n#define CONFIG scs::EasySingleton<ConfigurationManager>::GetInstance()\n\nstruct ConfigurationManager {\n  int a;\n  int b;\n};\n\nvoid func1() {\n  // Print 25\n  std::cout << CONFIG->a << std::endl;\n  // Print 30\n  std::cout << CONFIG->b << std::endl;\n}\n\nint main() {\n  // Config instance will be allocated here\n  // Set the "a" entry to 25\n  CONFIG->a = 25;\n  // Set the "b" entry to 30\n  CONFIG->b = 30;\n  // Call func1\n  func1();\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example, the CONFIG macro can be called from any function.\nThere is no need to pass CONFIG to the function func1 directly.\nThe main benefit of the singleton is you don't have to pass around the\nsame parameters everywhere."}),"\n",(0,i.jsx)(n.h2,{id:"easy-singleton",children:"Easy Singleton"}),"\n",(0,i.jsx)(n.p,{children:"One way to implement a singleton is in header files. Below is an example of\nhow to implement the EasySingleton."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"namespace scs {\n\n/**\n * A class to represent singleton pattern\n * Does not require specific initialization of the static variable\n * */\ntemplate<typename T>\nclass EasySingleton {\n protected:\n  /** static instance. */\n  static T* obj_;\n  static std::mutex lock_;\n\n public:\n  /**\n   * Uses unique pointer to build a static global instance of variable.\n   * @tparam T\n   * @return instance of T\n   */\n  template<typename ...Args>\n  static T* GetInstance(Args&& ...args) {\n    if (obj_ == nullptr) {\n      lock_.lock();\n      if (obj_ == nullptr) {\n        obj_ = new T(std::forward<Args>(args)...);\n      }\n      lock_.unlock();\n    }\n    return obj_;\n  }\n};\ntemplate <typename T>\nT* EasySingleton<T>::obj_ = nullptr;\ntemplate <typename T>\nstd::mutex EasySingleton<T>::lock_;\n\n}  // namespace scs\n"})}),"\n",(0,i.jsx)(n.p,{children:"This implementation is also thread-safe. Multiple threads can try to\naccess the singleton at the same time. This is important when dealing\nwith multi-threaded codebases. It is possible that multiple threads\nwill try to initialize the singleton at the same time, which can\ncause segfaults."}),"\n",(0,i.jsx)(n.h2,{id:"singleton-1",children:"Singleton"}),"\n",(0,i.jsx)(n.p,{children:"One limitation of the Easy Singleton is that an instance of the singleton\nwill be created for each shared object that accesses the singleton. If you use the singleton across different libraries, you will create a copy of the singleton for each shared object, which can lead to initialization and correctness issues."}),"\n",(0,i.jsx)(n.p,{children:"If you plan to use the singleton across shared objects, you need to implement the singleton as a shared object itself, and then link against it in your CMake."})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>o});var i=t(7294);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);