"use strict";(self.webpackChunkgnosis=self.webpackChunkgnosis||[]).push([[1270],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,k=c["".concat(s,".").concat(d)]||c[d]||u[d]||r;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1070:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},l="HERMES Setting",o={unversionedId:"Hermes/Hermes-components/Data-Placement-Strategies",id:"Hermes/Hermes-components/Data-Placement-Strategies",title:"HERMES Setting",description:"Every Hermes system instance includes one or more Hermes nodes.",source:"@site/docs/03-Hermes/06-Hermes-components/04-Data-Placement-Strategies.md",sourceDirName:"03-Hermes/06-Hermes-components",slug:"/Hermes/Hermes-components/Data-Placement-Strategies",permalink:"/docs/Hermes/Hermes-components/Data-Placement-Strategies",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Buffering-Target",permalink:"/docs/Hermes/Hermes-components/Buffering-Target"},next:{title:"Data-Staging",permalink:"/docs/Hermes/Hermes-components/Data-Staging"}},s={},p=[{value:"Error Handling",id:"error-handling",level:2}],m={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"hermes-setting"},"HERMES Setting"),(0,i.kt)("p",null,"Every Hermes system instance includes one or more Hermes ",(0,i.kt)("em",{parentName:"p"},"nodes"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"destination"),' is a buffering resource that can be identified by a pair\nof node + target "coordinates."'),(0,i.kt)("p",null,"Each target $",(0,i.kt)("inlineCode",{parentName:"p"},"t_k"),"$ has characteristics such as the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A capacity $",(0,i.kt)("inlineCode",{parentName:"li"},"Cap[t_k]"),"$"),(0,i.kt)("li",{parentName:"ul"},"A remaining capacity $",(0,i.kt)("inlineCode",{parentName:"li"},"Rem[t_k]"),"$"),(0,i.kt)("li",{parentName:"ul"},"A speed (or throughput) $",(0,i.kt)("inlineCode",{parentName:"li"},"Speed[...,t_k]"),"$",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This is the mean of the throughputs of all ranks associated with\nthe destination's node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Fix this","!")," Speed is really a function of the origin.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," At any point in time, there's a degree of ",(0,i.kt)("em",{parentName:"p"},"uncertainty")," to\nsome of the destination characteristics. For example, the remaining\ncapacity of a destination is typically obtained from a global metadata (MD)\nstructure that is updated asynchronously. Only the Hermes node buffer\npool managers have the precise value(s) for the pool under their\nmanagement."),(0,i.kt)("h1",{id:"the-data-placement-problem"},"The Data Placement Problem"),(0,i.kt)("p",null,"Given ",(0,i.kt)("em",{parentName:"p"},"N")," storage targets, a data placement policy ",(0,i.kt)("em",{parentName:"p"},"P"),", a cost function ",(0,i.kt)("em",{parentName:"p"},"F"),", and a ",(0,i.kt)("em",{parentName:"p"},"BLOB"),",\na data placement consists of a BLOB partitioning and an assignment of those parts to storage targets\nthat satisfies the constraints of the data placement policy and that minimizes the cost function."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Epoch - interval within which we update targets (status).",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Static (e.g., time interval or number of operations)"),(0,i.kt)("li",{parentName:"ul"},"Dynamic, i.e., computed by the delta of status")))),(0,i.kt)("p",null,"[","optional","]"," Placement window - interval within which we make data\nplacement decisions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Timer expired or I/O operation count reached, which ever comes\nfirst."),(0,i.kt)("li",{parentName:"ul"},"Static (e.g., time interval or number of operations)"),(0,i.kt)("li",{parentName:"ul"},"Dynamic, i.e., number of put operations")),(0,i.kt)("p",null,"Epoch and placement window could be aligned (static mode)."),(0,i.kt)("p",null,"The data placement is done within Data Placement Engine (DPE) component\nin HERMES."),(0,i.kt)("h1",{id:"the-data-placement-loop"},"The Data Placement Loop"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"placement schema")," $",(0,i.kt)("inlineCode",{parentName:"p"},"PS(b)"),"$ of a BLOB $",(0,i.kt)("inlineCode",{parentName:"p"},"b (>0)"),"$ is a decomposition\n$",(0,i.kt)("inlineCode",{parentName:"p"},"b = s_1+\\cdots+s_k,\\; s_i\\in\\mathbb{N}\\setminus\\{0\\}"),"$ together with a\ntarget mapping $",(0,i.kt)("inlineCode",{parentName:"p"},"(s_1,\\ldots,s_k)\\mapsto(t_1(s_1),\\ldots,t_k(s_k))"),"$."),(0,i.kt)("p",null,"A sequence of buffer IDs $",(0,i.kt)("inlineCode",{parentName:"p"},"(ID_1,\\ldots,ID_A)"),"$ ",(0,i.kt)("em",{parentName:"p"},"conforms")," to a target\nassignment $",(0,i.kt)("inlineCode",{parentName:"p"},"(s, t)"),"$, iff $",(0,i.kt)("inlineCode",{parentName:"p"},"s = \\sum_{i=1}^A Size(ID_i)"),"$ and\n$",(0,i.kt)("inlineCode",{parentName:"p"},"\\forall i\\;Target(ID_i) = t"),"$."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"allocation of a placement schema")," is a sequence of buffer IDs which\nis the concatenation of conforming target assignments."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Given: a vector of BLOBs $",(0,i.kt)("inlineCode",{parentName:"li"},"(b_1, b_2,\\ldots, b_B)"),"$"),(0,i.kt)("li",{parentName:"ol"},"The DPE creates placement schemas $",(0,i.kt)("inlineCode",{parentName:"li"},"PS(b_i),\\;1\\leq i\\leq B"),"$."),(0,i.kt)("li",{parentName:"ol"},"The placement schemas are presented to the buffer manager, which,\nfor each placement schema, returns an allocation of that schema (or\nan error), and updates the underlying metadata structures."),(0,i.kt)("li",{parentName:"ol"},"I/O clients transfer data from the BLOBs to the buffers.")),(0,i.kt)("h1",{id:"problem-to-solve-in-dpe"},"Problem to Solve in DPE"),(0,i.kt)("p",null,"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Vector of BLOBs $",(0,i.kt)("inlineCode",{parentName:"li"},"(b_1, b_2,\\ldots, b_B)"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of targets $",(0,i.kt)("inlineCode",{parentName:"li"},"(t_1, t_2,\\ldots, t_D)"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of target remaining capacities $",(0,i.kt)("inlineCode",{parentName:"li"},"Rem[t_k], \\;1\\leq k\\leq D"),"$."),(0,i.kt)("li",{parentName:"ul"},"Vector of target speed $",(0,i.kt)("inlineCode",{parentName:"li"},"Speed[t_k], \\;1\\leq k\\leq D"),"$.")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Placement schema\n$",(0,i.kt)("inlineCode",{parentName:"li"},"(s_1,\\ldots,s_k)\\mapsto(t_1(s_1),\\ldots,t_k(s_k))"),"$, where\n$",(0,i.kt)("inlineCode",{parentName:"li"},"b (>0)"),"$ is a decomposition\n$",(0,i.kt)("inlineCode",{parentName:"li"},"b = s_1+\\cdots+s_k,\\; s_i\\in\\mathbb{N}\\setminus\\{0\\}"),"$")),(0,i.kt)("h1",{id:"data-placement-solution"},"Data Placement Solution"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Pick a DP solver to obtain a ",(0,i.kt)("em",{parentName:"li"},"placement schema"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Linear programming",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Constraints"),(0,i.kt)("li",{parentName:"ul"},"Objective function"))),(0,i.kt)("li",{parentName:"ul"},"Round-robin",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Granularity"))),(0,i.kt)("li",{parentName:"ul"},"Random",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Distribution(s)"))))),(0,i.kt)("li",{parentName:"ol"},'Use the buffer pool\'s "coin selector" to convert into buffer IDs.'),(0,i.kt)("li",{parentName:"ol"},"Handle two types of potential errors.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"DP solver failure: This can happen because of outdated target\nstatus, i.e., insufficient capacity, constraint infeasibility,\netc.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Solution to insufficient capacity: epoch, decision windows,\nswap space."),(0,i.kt)("li",{parentName:"ul"},"Solution to constraint infeasibility: buffer reorganization,\ntarget filtering."))),(0,i.kt)("li",{parentName:"ul"},"Coin selection failure: This can happen because of outdated\nstate view information, e.g., outdated remaining capacities.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Solution: epoch, decision windows, swap space.")))))),(0,i.kt)("h2",{id:"error-handling"},"Error Handling"),(0,i.kt)("p",null,"In both cases, the list of targets is inappropriate and needs to be\nupdated or changed."),(0,i.kt)("p",null,'The list of "relevant destinations" for a rank is assembled by the\nHermes node ',(0,i.kt)("em",{parentName:"p"},"topology generator"),'. It gets triggered when DP fails. The\ninitial topology consists of "node-local" destinations (Plan A) plus a\nbackup list of neighbors (Plan B) to consult when a rank gets in\ntrouble. If both plans fail, the topology generator invokes the\n',(0,i.kt)("em",{parentName:"p"},"application-level"),' "rebalancer" to redraw neighborhood boundaries\n(Plan C). In the past, we used to call these components node- and\napplication-level DPEs, but they aren\'t directly involved in DP\ndecisions, and we need maybe a clearer terminology.'),(0,i.kt)("h1",{id:"data-placement-solution-implementation"},"Data Placement Solution Implementation"),(0,i.kt)("p",null,"LP solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pick Google OR-Tools as a linear optimization tool to obtain\na\xa0",(0,i.kt)("em",{parentName:"li"},"placement schema"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Minimize client I/O time.")))),(0,i.kt)("p",null,"Round-robin solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pick the next ",(0,i.kt)("em",{parentName:"li"},"target")," if the remaining capacity is greater or equal\nto the BLOB size, otherwise check the one after the next target\nuntil a target with enough capacity is found.")),(0,i.kt)("p",null,"Random solver"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Randomly pick a target from all targets which have the capacity\ngreater or equal to the BLOB size.")),(0,i.kt)("h1",{id:"experimental-setup"},"Experimental Setup"),(0,i.kt)("p",null,"Scaling the number of BLOBs, 10 GB total BLOB size"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Small size BLOBs: random within the range of 4KB to 64KB"),(0,i.kt)("li",{parentName:"ul"},"Medium size BLOBs: random within the range of 64KB to 1MB"),(0,i.kt)("li",{parentName:"ul"},"Large size BLOBs: random within the range of 1MB to 4MB"),(0,i.kt)("li",{parentName:"ul"},"Extra large size BLOBs: random with the range 4MB to 64MB"),(0,i.kt)("li",{parentName:"ul"},"Huge size BLOBs: fixed 1GB")),(0,i.kt)("p",null,"Scaling the BLOB size, 1,000 and 8,192 BLOBs in total"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Fixed BLOB size of 4KB, 64KB, 1MB, 4MB, 64MB")),(0,i.kt)("h1",{id:"experimental-results"},"Experimental Results"),(0,i.kt)("p",null,"The DPE time of three different solvers with 10GB BLOBs in total."),(0,i.kt)("p",null,"[","[../images/Picture1_11.jpg]","]"),(0,i.kt)("p",null,"[","[../images/Picture2_1.jpg]","]"),(0,i.kt)("p",null,"[","[../images/Picture3_1.jpg]","]"),(0,i.kt)("p",null,"The associated I/O time of placement schema from three different solvers\nwith 10GB BLOBs in total."),(0,i.kt)("p",null,"[","[../images/Picture6_1.jpg]","]"),(0,i.kt)("p",null,"[","[../images/Picture5_1.jpg]","]"),(0,i.kt)("p",null,"[","[../images/Picture4_1.jpg]","]"),(0,i.kt)("p",null,"The DPE time of three different solvers with 1,000 BLOBs in total."),(0,i.kt)("p",null,"[","[../images/rr_dpe.jpg]","]"),(0,i.kt)("p",null,"[","[../images/random_dpe.jpg]","]"),(0,i.kt)("p",null,"[","[../images/or_dpe.jpg]","]"),(0,i.kt)("p",null,"The associated I/O time by placement schema by three different solvers\nwith 1,000 BLOBs in total."),(0,i.kt)("p",null,"[","[../images/rr_io.jpg]","]"),(0,i.kt)("p",null,"[","[../images/random_io.jpg]","]"),(0,i.kt)("p",null,"[","[../images/ortools_io.jpg]","]"),(0,i.kt)("h1",{id:"conclusions"},"Conclusions"),(0,i.kt)("p",null,"For a fixed total size of many BLOBs, DPE time is increasing with the\nnumber of BLOBs for all solvers."),(0,i.kt)("p",null,"Round-robin and random solver can quickly calculate targets for a BLOB\nthan LP solver, while not considering optimizing I/O time."),(0,i.kt)("p",null,"LP solver is efficient when the search space (number of targets) is not\ntoo large (for example, less than 1,024)."),(0,i.kt)("p",null,"LP solver is a good candidate to place large size BLOBs, where the DPE\ntime has less impact than the I/O time to the overall performance."),(0,i.kt)("p",null,"One of the possible policies is that size 64KB could be a boundary for\nBLOB aggregation. BLOB size less than 64KB will be aggregated within a\nplacement window and than placed together to mitigate DPE impact."),(0,i.kt)("p",null,"Another possible policy is to use round-robin or random for small blobs\nand LP solver for large blobs."))}u.isMDXComponent=!0}}]);