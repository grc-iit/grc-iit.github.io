"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[46876],{5540:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-basic-syntax","title":"C++ Basic Syntax","description":"In this section, we will discuss some basic concepts of C and C++.","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/04-cpp-basic-syntax.mdx","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-basic-syntax","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-basic-syntax","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Building C++ with CMake","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-build-with-cmake"},"next":{"title":"C++ Style and Documentation","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-style-and-doc"}}');var s=t(74848),r=t(28453);const l={},c="C++ Basic Syntax",d={},a=[{value:"Builtin Numeric Types",id:"builtin-numeric-types",level:2},{value:"Sized Types",id:"sized-types",level:2},{value:"Simple Arrays",id:"simple-arrays",level:2},{value:"Structs",id:"structs",level:2},{value:"Memory Allocation and Pointers",id:"memory-allocation-and-pointers",level:2},{value:"Malloc + Free",id:"malloc--free",level:3}];function o(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"c-basic-syntax",children:"C++ Basic Syntax"})}),"\n",(0,s.jsx)(n.p,{children:"In this section, we will discuss some basic concepts of C and C++.\nWe discuss both C and C++ since you will likely see both."}),"\n",(0,s.jsx)(n.h2,{id:"builtin-numeric-types",children:"Builtin Numeric Types"}),"\n",(0,s.jsx)(n.p,{children:"C++ has a number of builtin integer types."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Keyword"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"char"}),(0,s.jsx)(n.td,{children:"A signed 1-byte integer. Can represent ASCII character codes. Always 1 byte."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsx)(n.td,{children:"A signed integer. Typically 4 bytes."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"float"}),(0,s.jsx)(n.td,{children:"A fractional number. Typically 4 bytes."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"double"}),(0,s.jsx)(n.td,{children:"A large fractional number. Typically 8 bytes."})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  int x;\n  float x;\n  double x;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There are also ",(0,s.jsx)(n.em,{children:"modifiers"})," which can be applied to these types. There\nare two primary types of modifiers: ",(0,s.jsx)(n.em,{children:"sign"})," modifiers and ",(0,s.jsx)(n.em,{children:"size"})," modifiers."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"sign"})," modifiers apply to int and char specifically."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Keyword"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"signed"}),(0,s.jsx)(n.td,{children:"The number can be negative"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"unsigned"}),(0,s.jsx)(n.td,{children:"The number cannot be negative"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"size"})," modifiers apply to int and double types specifically."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Keyword"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Applies to doubles?"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"short"}),(0,s.jsx)(n.td,{children:"Decrease length of type"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"long"}),(0,s.jsx)(n.td,{children:"Increase length of type"}),(0,s.jsx)(n.td,{children:"Yes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"long long"}),(0,s.jsx)(n.td,{children:"Increase length of type more"}),(0,s.jsx)(n.td,{children:"Yes"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Below are a few examples of the above:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  // int examples\n  long int a;\n  long long int b;\n  unsigned int c;\n  long unsigned int d;\n  unsigned long int e;\n  short int f;\n  short g;\n  long h;\n\n  // Double examples\n  long double g;\n  long long double h;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sized-types",children:"Sized Types"}),"\n",(0,s.jsxs)(n.p,{children:["Certain types are guaranteed to have a specific size. They are included\nin the ",(0,s.jsx)(n.em,{children:"stdint.h"})," header file. Having a specific size to types is frequently\nuseful."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Keyword"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int8_t"}),(0,s.jsx)(n.td,{children:"Signed 8-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int16_t"}),(0,s.jsx)(n.td,{children:"Signed 16-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int32_t"}),(0,s.jsx)(n.td,{children:"Signed 32-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int64_t"}),(0,s.jsx)(n.td,{children:"Signed 64-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint8_t"}),(0,s.jsx)(n.td,{children:"Unsigned 8-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint16_t"}),(0,s.jsx)(n.td,{children:"Unsigned 16-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint32_t"}),(0,s.jsx)(n.td,{children:"Unsigned 32-bit integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint64_t"}),(0,s.jsx)(n.td,{children:"Unsigned 64-bit integer"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Examples are below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <stdint.h>\n\nint main() {\n  int8_t a;\n  int16_t b;\n  uint64_t c;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"simple-arrays",children:"Simple Arrays"}),"\n",(0,s.jsx)(n.p,{children:"Arrays provide a way to define many instances of a single type quickly. Arrays\nare stored on the stack, and have limited space. Typically, an array shouldn't\nexceed more than 16KB of memory. This is not a hard rule, but I find it to be\ngenerally safe.  Larger allocations should be made on the heap using a memory\nallocator, which is described later."}),"\n",(0,s.jsx)(n.p,{children:"An example is below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  int hello[24];\n\n  hello[0] = 0;\n  hello[1] = 0;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We create an array containing 24 ints. We then set the first two elements\nof the array to 0."}),"\n",(0,s.jsx)(n.p,{children:"Arrays can also be initialized as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int main() {\n  int hello[24] = {\n    0, 1, 2, 3, 4, 5, 0\n  };\n\n  int hello2[24] = {0};\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first five elements of ",(0,s.jsx)(n.em,{children:"hello"})," are initialized to 0 through 5. Elements 6\nand onwards are initialized to 0."]}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.em,{children:"hello2"}),", all elements are initialized to 0."]}),"\n",(0,s.jsx)(n.h2,{id:"structs",children:"Structs"}),"\n",(0,s.jsx)(n.p,{children:"structs can be used to logically group data."}),"\n",(0,s.jsx)(n.p,{children:"For example, we can create a struct to represent a wallet. The wallet contains\nmoney (in cents), driver's license, and a health insurance card."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <stdint.h>\n\nstruct Wallet {\n  uint8_t cents_;\n  char license_[32];\n  char health_id_[32];\n};  // notice the ; here\n\nint main() {\n  struct Wallet wallet;\n  wallet.pennies_ = 200;\n  strcpy(wallet.license_, "dontpullmeover");\n  strcpy(wallet.health_id_, "donthurtme");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:'Our wallet contains 200 cents, a license with the text "dontpullmeover",\nand a health insure ID which states "donthurtme".'}),"\n",(0,s.jsx)(n.p,{children:"In addition, structs can be initialized using a special syntax to reduce lines\nof code. Here we initialize the Lemonade struct. The lemonade can have a certain\namount of sugar, water, lemon juice, and coloring."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Lemonade {\n  int sugar_;  // grams\n  int water_;  // mL\n  int lemon_;  // mL\n  int color_[3];  // (Red, Green, Blue)\n}\n\nint main() {\n  // NOTE: 255, 255, 0 is yellow on the RGB color wheel\n  struct Lemonade sour = {0, 100, 10,\n                          255,255,0};\n  struct Lemonade sweet = {20, 100, 10,\n                           255,255,0};\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"memory-allocation-and-pointers",children:"Memory Allocation and Pointers"}),"\n",(0,s.jsx)(n.h3,{id:"malloc--free",children:"Malloc + Free"}),"\n",(0,s.jsxs)(n.p,{children:["The very vast majority of data must be stored using a memory allocator.\nThe C-style way to do this is with malloc and free. Generally, it's\nbad practice to directly use ",(0,s.jsx)(n.code,{children:"malloc"})," and ",(0,s.jsx)(n.code,{children:"free"}),". However, sometimes\nit is unavoidable. ",(0,s.jsx)(n.code,{children:"malloc"})," allocates memory, ",(0,s.jsx)(n.code,{children:"free"})," releases memory.\nWhen you fail to release memory using ",(0,s.jsx)(n.code,{children:"free"}),", it is referred to as a\n",(0,s.jsx)(n.strong,{children:"memory leak"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <cstdlib>  // malloc + free\n#include <cstring>  // memset\n\nint main() {\n  // Allocate\n  int *data = (int*)malloc(64 * sizeof(int));\n  // Clear\n  memset(data, 0, 64 * sizeof(int));\n\n  // Set integer 10 to 15\n  data[10] = 15;\n\n  // Allocate + clear\n  int *data2 = (int*)calloc(64, sizeof(int));\n\n  // Set integer 10 to 15\n  data2[10] = 15;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var i=t(96540);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);