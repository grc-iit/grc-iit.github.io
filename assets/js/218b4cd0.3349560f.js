"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[77957],{66513:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs","title":"C++ References and Pointers","description":"C++ has various ways to pass data and manage memory. This section goes","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/07-cpp-refs-and-ptrs.mdx","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C++ Classes","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-classes"},"next":{"title":"C++ Data Structures","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-data-structures"}}');var t=s(74848),a=s(28453);const o={},i="C++ References and Pointers",c={},l=[{value:"Rvalues, Lvalues",id:"rvalues-lvalues",level:2},{value:"Rvalues and Lvalues",id:"rvalues-and-lvalues",level:3},{value:"Constructors and Destructors Revisited",id:"constructors-and-destructors-revisited",level:2},{value:"Copy Constructor",id:"copy-constructor",level:3},{value:"Move Constructor",id:"move-constructor",level:3},{value:"Moving and copying",id:"moving-and-copying",level:2},{value:"Passing as a Copy",id:"passing-as-a-copy",level:3},{value:"Passing as a Move",id:"passing-as-a-move",level:3},{value:"Smart Pointers",id:"smart-pointers",level:2},{value:"<code>std::shared_ptr</code>",id:"stdshared_ptr",level:3},{value:"<code>std::unique_ptr</code>",id:"stdunique_ptr",level:3},{value:"<code>std::weak_ptr</code>",id:"stdweak_ptr",level:3},{value:"Dangling Pointers",id:"dangling-pointers",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"c-references-and-pointers",children:"C++ References and Pointers"})}),"\n",(0,t.jsx)(n.p,{children:"C++ has various ways to pass data and manage memory. This section goes\ninto more details"}),"\n",(0,t.jsx)(n.h2,{id:"rvalues-lvalues",children:"Rvalues, Lvalues"}),"\n",(0,t.jsxs)(n.p,{children:["In C++, understanding the concepts of ",(0,t.jsx)(n.strong,{children:"rvalues"})," and ",(0,t.jsx)(n.strong,{children:"lvalues"})," is crucial for efficient resource management and parameter passing. Additionally, knowing how to pass objects as copies or moves and working with managed pointers is essential for effective memory management."]}),"\n",(0,t.jsx)(n.h3,{id:"rvalues-and-lvalues",children:"Rvalues and Lvalues"}),"\n",(0,t.jsxs)(n.p,{children:["In C++, every expression yields either an ",(0,t.jsx)(n.strong,{children:"lvalue"})," or an ",(0,t.jsx)(n.strong,{children:"rvalue"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lvalues"}),": Lvalues are expressions that represent objects with a persistent identity. They typically correspond to variables, data members, or objects with names. Lvalues can appear on both the left and right sides of an assignment."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rvalues"}),": Rvalues are expressions that represent temporary values, often used on the right side of an assignment. They do not have a persistent identity and are usually the result of operations or computations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int x = 42;       // 'x' is an lvalue\nint y = x + 5;    // 'x + 5' is an rvalue\n"})}),"\n",(0,t.jsx)(n.h2,{id:"constructors-and-destructors-revisited",children:"Constructors and Destructors Revisited"}),"\n",(0,t.jsx)(n.p,{children:"Constructors and destructors are special member functions that play a crucial role in object creation and resource management. In C++, you can define multiple constructors to create objects in various ways, and destructors ensure that resources are released when an object goes out of scope."}),"\n",(0,t.jsx)(n.h3,{id:"copy-constructor",children:"Copy Constructor"}),"\n",(0,t.jsx)(n.p,{children:"A copy constructor is a constructor used to create a new object as a copy of an existing object. It is invoked when an object is passed by value or returned by value. Properly implementing copy constructors is essential for handling objects correctly in C++."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class MyClass {\nprivate:\n    int data;\n\npublic:\n    MyClass(int d) : data(d) {}\n\n    // Copy constructor\n    MyClass(const MyClass& other) : data(other.data) {}\n};\n\n// Usage\nint main() {\n    MyClass obj1(42);\n    MyClass obj2 = obj1; // Copy constructor invoked\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"move-constructor",children:"Move Constructor"}),"\n",(0,t.jsx)(n.p,{children:"Move constructors are introduced in C++11 and are used to efficiently transfer ownership of resources (such as memory) from one object to another. They are invoked when moving objects, typically improving performance in scenarios involving dynamic memory management."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'class MyString {\nprivate:\n    char* str;\n\npublic:\n    MyString(char* s) : str(s) {}\n\n    // Move constructor\n    MyString(MyString&& other) noexcept : str(other.str) {\n        other.str = nullptr;\n    }\n};\n\n// Usage\nint main() {\n    char* text = "Hello, World!";\n    MyString str1(text);\n    MyString str2 = std::move(str1); // Move constructor invoked\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"moving-and-copying",children:"Moving and copying"}),"\n",(0,t.jsx)(n.h3,{id:"passing-as-a-copy",children:"Passing as a Copy"}),"\n",(0,t.jsx)(n.p,{children:"Passing an object as a copy involves creating a duplicate of the object, which can be useful when you want to isolate changes made within a function from the original object."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void modifyValue(int value) {\n    value *= 2;\n}\n\nint main() {\n    int num = 10;\n    modifyValue(num); // Passing 'num' as a copy\n    // 'num' remains unchanged\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"passing-as-a-move",children:"Passing as a Move"}),"\n",(0,t.jsx)(n.p,{children:"Passing an object as a move is more efficient than copying when you intend to transfer ownership of resources, like dynamically allocated memory, to another object. It involves the use of move constructors and move assignment operators."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class MyString {\nprivate:\n    char* str;\n\npublic:\n    MyString(char* s) : str(s) {}\n\n    // Move constructor\n    MyString(MyString&& other) noexcept : str(other.str) {\n        other.str = nullptr;\n    }\n};\n\nint main() {\n    char* text = \"Hello, World!\";\n    MyString str1(text);\n    MyString str2 = std::move(str1); // Passing 'str1' as a move\n    // 'str1' is now in a valid but unspecified state\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"of pointers in C++ that offer different levels of control and responsibility."}),"\n",(0,t.jsx)(n.h2,{id:"smart-pointers",children:"Smart Pointers"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Smart pointers"})," are a category of pointers that provide automatic memory management by tracking the lifetime of dynamically allocated objects. They help ensure that memory is properly deallocated when it's no longer needed. C++ provides three main types of smart pointers:"]}),"\n",(0,t.jsx)(n.h3,{id:"stdshared_ptr",children:(0,t.jsx)(n.code,{children:"std::shared_ptr"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ownership"}),": Shared ownership among multiple shared_ptr instances."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": When multiple pointers need access to the same dynamically allocated object."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Overhead"}),": Slightly higher overhead due to reference counting."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#include <memory>\n\nstd::shared_ptr<int> numPtr = std::make_shared<int>(42);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"stdunique_ptr",children:(0,t.jsx)(n.code,{children:"std::unique_ptr"})}),"\n",(0,t.jsx)(n.p,{children:"Ownership: Exclusive ownership; cannot be shared or copied.\nUse Case: When a single owner manages the dynamically allocated object.\nPerformance: Lower overhead compared to shared_ptr.\nExample:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#include <memory>\n\nstd::unique_ptr<int> numPtr = std::make_unique<int>(42);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"stdweak_ptr",children:(0,t.jsx)(n.code,{children:"std::weak_ptr"})}),"\n",(0,t.jsx)(n.p,{children:"Ownership: Weak reference to an object managed by shared_ptr.\nUse Case: To avoid circular references and break potential reference cycles.\nUsage: Convert to shared_ptr when access is needed.\nExample:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#include <memory>\n\nstd::shared_ptr<int> sharedPtr = std::make_shared<int>(42);\nstd::weak_ptr<int> weakPtr = sharedPtr;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dangling-pointers",children:"Dangling Pointers"}),"\n",(0,t.jsx)(n.p,{children:"Dangling pointers occur when a pointer references memory that has been deallocated, leading to undefined behavior.\nBy using smart pointer classes, danlging pointer errors can be reduced."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var r=s(96540);const t={},a=r.createContext(t);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);